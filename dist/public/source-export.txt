
========================================
FILE: replit.md
========================================
# Kid Video App

## Overview

A kid-friendly YouTube video watching application where parents can manage a curated playlist of videos for their children. Parents add YouTube video URLs and assign them to kids (up to 6 children), while kids can watch videos in a safe, distraction-free environment. Videos must be completed before being marked as watched.

## Recent Changes (February 2026)
- Added trial status display in parent dashboard: shows countdown (30-15 days), freezes to "upgrade anytime" (<=15 days), hidden after 30 days or for expired trials
- Added master admin / global playlists system: app developer (MASTER_USER_ID env var) creates global playlists; parents can subscribe to add them to their kids' libraries
- Global playlist subscription copies master videos into parent's library with "Curated" badge; auto-syncs new videos on every dashboard load
- Added "Move to folder" button on each video in library (FolderPlus icon) - move unfiled videos into folders without losing recordings
- Custom YouTube player for kid mode: distraction-free with play/pause, rewind 10s, fast-forward 10s, scrub bar, and time display (uses YouTube IFrame API with controls=0)
- Progress tracking now uses actual watched time (only counts when playing, pauses don't count)
- Fixed "Last 7 Days" stats to always show rolling 7-day total regardless of which day it is
- Renamed "Folder" to "Playlist" throughout the UI
- Added inline "Add Kid" on parent home screen (between header and Add Video card)
- Added "Download App Icon" button in the Add to Home Screen dialog
- Added direct icon download endpoint at /api/download-icon
- Added PWA badge counts on home screen icons (WhatsApp-style): kids see unwatched video count, parents see new completion count
- Improved voice recording UX: larger timer, re-record option, 0-second recordings rejected with feedback
- Fixed error messages showing raw JSON - now displays clean user-friendly text
- Fixed kids list not updating after adding a kid (queryFn override bug)
- Added multi-family support with Replit Auth - each family has separate private data (kids, videos, folders)
- Added feedback system with 4 input types: text, voice recording, video link, screenshot
- Parent mode header now includes: feedback button, settings button, logout button
- Landing page for unauthenticated users with features showcase and login

## Recent Changes (January 2026)
- Added quick priority editing: tap the Lv.X button on any video in library to cycle through levels 1-9
- Improved paste button UX: now pastes directly without confirmation toast
- Added TikTok video support (add TikTok links, embedded playback within app)
- Added paste button for quickly pasting video links from clipboard
- Added folder renaming feature (click pencil icon to edit folder names)
- Added PWA support with per-kid home screen shortcuts (copy kid link at /kid/:kidId, add to home screen on iOS/Android)
- Added "Add to Home Screen" button in kid mode with platform-specific instructions (iOS/Android)
- Added folder organization for videos (create folders like "Crude Oil Videos", assign videos to folders)
- Added video preview/play feature in parent mode (click thumbnail or play button to preview before assigning)
- Video library now organized by collapsible folders with "Unfiled" section for videos without folders
- Added multi-select kid assignment when adding videos (can assign to specific kids or "all kids")
- Added voice recording requirement for video completion (kids must record voice description after watching)
- Implemented max 4 views per video limit with UI feedback (view count badges, red warning when maxed)
- Backend validation for voice recording duration > 0
- Added data-testids to all interactive and key display elements
- Fixed hover/active class violations in buttons per design guidelines
- Moved "Add Kid" functionality to settings dialog (accessible via settings icon in header)
- Added per-kid stats summary badges showing watched/total video counts on parent home screen
- Enhanced voice recording to save audio data (base64 data URL) for parent playback
- Added playback buttons for kid voice recordings in video library (parents can listen to kid recordings)
- Made UI more compact with smaller fonts throughout

## Core Features
- **Master Admin / Global Playlists**: App developer (MASTER_USER_ID) creates global playlists; parents subscribe to add curated videos to their kids' libraries. Subscribed playlists show "Curated" badge and auto-sync new videos.
- **Parent Mode**: Add kids (max 6), create folders, add YouTube videos with folder/kid selection, preview videos, manage video library
- **Folder Organization**: Create named folders (e.g., "Crude Oil Videos") to organize videos; videos grouped by folder in library
- **Video Preview**: Parents can preview videos before assigning by clicking thumbnail or play button
- **Kid Mode**: Select kid profile, view assigned videos organized by folders/topics, watch videos in embedded player
- **Video Completion**: 2-step completion: 1) watch video (3 second demo timeout), 2) record voice description
- **Voice Recording**: Press-and-hold mic button to record what was learned from the video
- **Video Priority**: Parents set priority levels 1-9 (1=basic, 9=advanced); kids must watch lower-level videos before unlocking advanced ones in each folder
- **View Limits**: Each video can be watched max 4 times total; videos at limit are disabled with red warning
- **Progress Tracking**: Each kid has separate watched/pending statistics
- **PWA Badge Counts**: Home screen icons show notification badges - kids see unwatched video count, parents see new completion count from all kids

## User Preferences

Preferred communication style: Simple, everyday language.

## System Architecture

### Frontend Architecture
- **Framework**: React 18 with TypeScript
- **Routing**: Wouter (lightweight alternative to React Router)
- **State Management**: TanStack React Query for server state
- **UI Components**: shadcn/ui component library built on Radix UI primitives
- **Styling**: Tailwind CSS with CSS variables for theming (light/dark mode support)
- **Build Tool**: Vite with hot module replacement

### Backend Architecture
- **Framework**: Express 5 (ES modules)
- **Runtime**: Node.js with tsx for TypeScript execution
- **API Design**: RESTful JSON API under `/api/*` prefix
- **Storage**: In-memory storage with interface abstraction (IStorage) for future database migration

### Data Storage
- **Current**: PostgreSQL database with Drizzle ORM for persistent storage
- **Schema**: Drizzle ORM with PostgreSQL dialect - tables: `kids`, `folders`, `videos`
- **Validation**: Zod schemas shared between client and server in `/shared/schema.ts`
- **Connection**: Node-postgres (pg) driver via `server/db/index.ts`

### Key Design Patterns
- **Shared Types**: Common schemas and types in `/shared` directory imported by both client and server
- **Path Aliases**: `@/` for client source, `@shared/` for shared code
- **Storage Interface**: Abstract storage interface allows swapping between memory and database storage

### Build System
- **Development**: Vite dev server with Express backend via middleware
- **Production**: Vite builds to `dist/public`, esbuild bundles server to `dist/index.cjs`
- **Database**: `npm run db:push` for Drizzle schema migrations

## External Dependencies

### Database
- **PostgreSQL**: Configured via `DATABASE_URL` environment variable
- **ORM**: Drizzle ORM with drizzle-zod for schema validation
- **Session Store**: connect-pg-simple for session persistence (available but not currently used)

### Third-Party Services
- **YouTube**: Extracts video IDs from YouTube URLs (watch, youtu.be, shorts, embed formats)
- **TikTok**: Extracts video IDs from TikTok URLs, auto-resolves short links (vm.tiktok.com, tiktok.com/t/) to full URLs server-side
- No external API integrations currently active

### Key npm Packages
- **UI**: Full shadcn/ui component suite (40+ Radix UI components)
- **Data Fetching**: @tanstack/react-query
- **Validation**: zod, drizzle-zod
- **Utilities**: date-fns, clsx, class-variance-authority

========================================
FILE: package.json
========================================
{
  "name": "rest-express",
  "version": "1.0.0",
  "type": "module",
  "license": "MIT",
  "scripts": {
    "dev": "NODE_ENV=development tsx server/index.ts",
    "build": "tsx script/build.ts",
    "start": "NODE_ENV=production node dist/index.cjs",
    "check": "tsc",
    "db:push": "drizzle-kit push"
  },
  "dependencies": {
    "@hookform/resolvers": "^3.10.0",
    "@jridgewell/trace-mapping": "^0.3.25",
    "@neondatabase/serverless": "^1.0.2",
    "@radix-ui/react-accordion": "^1.2.4",
    "@radix-ui/react-alert-dialog": "^1.1.7",
    "@radix-ui/react-aspect-ratio": "^1.1.3",
    "@radix-ui/react-avatar": "^1.1.4",
    "@radix-ui/react-checkbox": "^1.1.5",
    "@radix-ui/react-collapsible": "^1.1.4",
    "@radix-ui/react-context-menu": "^2.2.7",
    "@radix-ui/react-dialog": "^1.1.7",
    "@radix-ui/react-dropdown-menu": "^2.1.7",
    "@radix-ui/react-hover-card": "^1.1.7",
    "@radix-ui/react-label": "^2.1.3",
    "@radix-ui/react-menubar": "^1.1.7",
    "@radix-ui/react-navigation-menu": "^1.2.6",
    "@radix-ui/react-popover": "^1.1.7",
    "@radix-ui/react-progress": "^1.1.3",
    "@radix-ui/react-radio-group": "^1.2.4",
    "@radix-ui/react-scroll-area": "^1.2.4",
    "@radix-ui/react-select": "^2.1.7",
    "@radix-ui/react-separator": "^1.1.3",
    "@radix-ui/react-slider": "^1.2.4",
    "@radix-ui/react-slot": "^1.2.0",
    "@radix-ui/react-switch": "^1.1.4",
    "@radix-ui/react-tabs": "^1.1.4",
    "@radix-ui/react-toast": "^1.2.7",
    "@radix-ui/react-toggle": "^1.1.3",
    "@radix-ui/react-toggle-group": "^1.1.3",
    "@radix-ui/react-tooltip": "^1.2.0",
    "@tanstack/react-query": "^5.60.5",
    "@types/memoizee": "^0.4.12",
    "@types/pg": "^8.16.0",
    "class-variance-authority": "^0.7.1",
    "clsx": "^2.1.1",
    "cmdk": "^1.1.1",
    "connect-pg-simple": "^10.0.0",
    "date-fns": "^3.6.0",
    "drizzle-orm": "^0.39.3",
    "drizzle-zod": "^0.7.0",
    "embla-carousel-react": "^8.6.0",
    "express": "^5.0.1",
    "express-session": "^1.19.0",
    "framer-motion": "^11.13.1",
    "input-otp": "^1.4.2",
    "lucide-react": "^0.453.0",
    "memoizee": "^0.4.17",
    "memorystore": "^1.6.7",
    "next-themes": "^0.4.6",
    "openid-client": "^6.8.1",
    "passport": "^0.7.0",
    "passport-local": "^1.0.0",
    "pg": "^8.17.2",
    "react": "^18.3.1",
    "react-day-picker": "^8.10.1",
    "react-dom": "^18.3.1",
    "react-hook-form": "^7.55.0",
    "react-icons": "^5.4.0",
    "react-resizable-panels": "^2.1.7",
    "recharts": "^2.15.2",
    "tailwind-merge": "^2.6.0",
    "tailwindcss-animate": "^1.0.7",
    "tw-animate-css": "^1.2.5",
    "vaul": "^1.1.2",
    "wouter": "^3.3.5",
    "ws": "^8.18.0",
    "zod": "^3.24.2",
    "zod-validation-error": "^3.4.0"
  },
  "devDependencies": {
    "@replit/vite-plugin-cartographer": "^0.4.4",
    "@replit/vite-plugin-dev-banner": "^0.1.1",
    "@replit/vite-plugin-runtime-error-modal": "^0.0.3",
    "@tailwindcss/typography": "^0.5.15",
    "@tailwindcss/vite": "^4.1.18",
    "@types/connect-pg-simple": "^7.0.3",
    "@types/express": "^5.0.0",
    "@types/express-session": "^1.18.2",
    "@types/node": "20.19.27",
    "@types/passport": "^1.0.17",
    "@types/passport-local": "^1.0.38",
    "@types/react": "^18.3.11",
    "@types/react-dom": "^18.3.1",
    "@types/ws": "^8.5.13",
    "@vitejs/plugin-react": "^4.7.0",
    "autoprefixer": "^10.4.20",
    "drizzle-kit": "^0.31.8",
    "esbuild": "^0.25.0",
    "postcss": "^8.4.47",
    "tailwindcss": "^3.4.17",
    "tsx": "^4.20.5",
    "typescript": "5.6.3",
    "vite": "^7.3.0"
  },
  "overrides": {
    "drizzle-kit": {
      "@esbuild-kit/esm-loader": "npm:tsx@^4.20.4"
    }
  },
  "optionalDependencies": {
    "bufferutil": "^4.0.8"
  }
}


========================================
FILE: tsconfig.json
========================================
{
  "include": ["client/src/**/*", "shared/**/*", "server/**/*"],
  "exclude": ["node_modules", "build", "dist", "**/*.test.ts"],
  "compilerOptions": {
    "incremental": true,
    "tsBuildInfoFile": "./node_modules/typescript/tsbuildinfo",
    "noEmit": true,
    "module": "ESNext",
    "strict": true,
    "lib": ["esnext", "dom", "dom.iterable"],
    "jsx": "preserve",
    "esModuleInterop": true,
    "skipLibCheck": true,
    "allowImportingTsExtensions": true,
    "moduleResolution": "bundler",
    "baseUrl": ".",
    "types": ["node", "vite/client"],
    "paths": {
      "@/*": ["./client/src/*"],
      "@shared/*": ["./shared/*"]
    }
  }
}


========================================
FILE: vite.config.ts
========================================
import { defineConfig } from "vite";
import react from "@vitejs/plugin-react";
import path from "path";
import runtimeErrorOverlay from "@replit/vite-plugin-runtime-error-modal";

export default defineConfig({
  plugins: [
    react(),
    runtimeErrorOverlay(),
    ...(process.env.NODE_ENV !== "production" &&
    process.env.REPL_ID !== undefined
      ? [
          await import("@replit/vite-plugin-cartographer").then((m) =>
            m.cartographer(),
          ),
          await import("@replit/vite-plugin-dev-banner").then((m) =>
            m.devBanner(),
          ),
        ]
      : []),
  ],
  resolve: {
    alias: {
      "@": path.resolve(import.meta.dirname, "client", "src"),
      "@shared": path.resolve(import.meta.dirname, "shared"),
      "@assets": path.resolve(import.meta.dirname, "attached_assets"),
    },
  },
  root: path.resolve(import.meta.dirname, "client"),
  build: {
    outDir: path.resolve(import.meta.dirname, "dist/public"),
    emptyOutDir: true,
  },
  server: {
    fs: {
      strict: true,
      deny: ["**/.*"],
    },
  },
});


========================================
FILE: tailwind.config.ts
========================================
import type { Config } from "tailwindcss";

export default {
  darkMode: ["class"],
  content: ["./client/index.html", "./client/src/**/*.{js,jsx,ts,tsx}"],
  theme: {
    extend: {
      borderRadius: {
        lg: ".5625rem", /* 9px */
        md: ".375rem", /* 6px */
        sm: ".1875rem", /* 3px */
      },
      colors: {
        // Flat / base colors (regular buttons)
        background: "hsl(var(--background) / <alpha-value>)",
        foreground: "hsl(var(--foreground) / <alpha-value>)",
        border: "hsl(var(--border) / <alpha-value>)",
        input: "hsl(var(--input) / <alpha-value>)",
        card: {
          DEFAULT: "hsl(var(--card) / <alpha-value>)",
          foreground: "hsl(var(--card-foreground) / <alpha-value>)",
          border: "hsl(var(--card-border) / <alpha-value>)",
        },
        popover: {
          DEFAULT: "hsl(var(--popover) / <alpha-value>)",
          foreground: "hsl(var(--popover-foreground) / <alpha-value>)",
          border: "hsl(var(--popover-border) / <alpha-value>)",
        },
        primary: {
          DEFAULT: "hsl(var(--primary) / <alpha-value>)",
          foreground: "hsl(var(--primary-foreground) / <alpha-value>)",
          border: "var(--primary-border)",
        },
        secondary: {
          DEFAULT: "hsl(var(--secondary) / <alpha-value>)",
          foreground: "hsl(var(--secondary-foreground) / <alpha-value>)",
          border: "var(--secondary-border)",
        },
        muted: {
          DEFAULT: "hsl(var(--muted) / <alpha-value>)",
          foreground: "hsl(var(--muted-foreground) / <alpha-value>)",
          border: "var(--muted-border)",
        },
        accent: {
          DEFAULT: "hsl(var(--accent) / <alpha-value>)",
          foreground: "hsl(var(--accent-foreground) / <alpha-value>)",
          border: "var(--accent-border)",
        },
        destructive: {
          DEFAULT: "hsl(var(--destructive) / <alpha-value>)",
          foreground: "hsl(var(--destructive-foreground) / <alpha-value>)",
          border: "var(--destructive-border)",
        },
        ring: "hsl(var(--ring) / <alpha-value>)",
        chart: {
          "1": "hsl(var(--chart-1) / <alpha-value>)",
          "2": "hsl(var(--chart-2) / <alpha-value>)",
          "3": "hsl(var(--chart-3) / <alpha-value>)",
          "4": "hsl(var(--chart-4) / <alpha-value>)",
          "5": "hsl(var(--chart-5) / <alpha-value>)",
        },
        sidebar: {
          ring: "hsl(var(--sidebar-ring) / <alpha-value>)",
          DEFAULT: "hsl(var(--sidebar) / <alpha-value>)",
          foreground: "hsl(var(--sidebar-foreground) / <alpha-value>)",
          border: "hsl(var(--sidebar-border) / <alpha-value>)",
        },
        "sidebar-primary": {
          DEFAULT: "hsl(var(--sidebar-primary) / <alpha-value>)",
          foreground: "hsl(var(--sidebar-primary-foreground) / <alpha-value>)",
          border: "var(--sidebar-primary-border)",
        },
        "sidebar-accent": {
          DEFAULT: "hsl(var(--sidebar-accent) / <alpha-value>)",
          foreground: "hsl(var(--sidebar-accent-foreground) / <alpha-value>)",
          border: "var(--sidebar-accent-border)"
        },
        status: {
          online: "rgb(34 197 94)",
          away: "rgb(245 158 11)",
          busy: "rgb(239 68 68)",
          offline: "rgb(156 163 175)",
        },
      },
      fontFamily: {
        sans: ["var(--font-sans)"],
        serif: ["var(--font-serif)"],
        mono: ["var(--font-mono)"],
      },
      keyframes: {
        "accordion-down": {
          from: { height: "0" },
          to: { height: "var(--radix-accordion-content-height)" },
        },
        "accordion-up": {
          from: { height: "var(--radix-accordion-content-height)" },
          to: { height: "0" },
        },
      },
      animation: {
        "accordion-down": "accordion-down 0.2s ease-out",
        "accordion-up": "accordion-up 0.2s ease-out",
      },
    },
  },
  plugins: [require("tailwindcss-animate"), require("@tailwindcss/typography")],
} satisfies Config;


========================================
FILE: drizzle.config.ts
========================================
import { defineConfig } from "drizzle-kit";

if (!process.env.DATABASE_URL) {
  throw new Error("DATABASE_URL, ensure the database is provisioned");
}

export default defineConfig({
  out: "./migrations",
  schema: "./shared/schema.ts",
  dialect: "postgresql",
  dbCredentials: {
    url: process.env.DATABASE_URL,
  },
});


========================================
FILE: components.json
========================================
{
    "$schema": "https://ui.shadcn.com/schema.json",
    "style": "new-york",
    "rsc": false,
    "tsx": true,
    "tailwind": {
      "config": "tailwind.config.ts",
      "css": "client/src/index.css",
      "baseColor": "neutral",
      "cssVariables": true,
      "prefix": ""
    },
    "aliases": {
      "components": "@/components",
      "utils": "@/lib/utils",
      "ui": "@/components/ui",
      "lib": "@/lib",
      "hooks": "@/hooks"
    }
}

========================================
FILE: client/index.html
========================================
<!DOCTYPE html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1" />
    <title>Kid Video App - Safe YouTube Watching for Kids</title>
    <meta name="description" content="A fun and safe way for kids to watch YouTube videos. Parents add videos, kids watch and complete them. No distractions, just learning and fun!" />
    <meta property="og:title" content="Kid Video App - Safe YouTube Watching for Kids" />
    <meta property="og:description" content="A fun and safe way for kids to watch YouTube videos. Parents add videos, kids watch and complete them. No distractions, just learning and fun!" />
    <meta property="og:type" content="website" />
    <meta property="og:image" content="/favicon.png" />
    <link rel="icon" type="image/png" href="/favicon.png" />
    <link rel="manifest" href="/manifest.json" />
    <meta name="theme-color" content="#7c3aed" />
    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="default" />
    <meta name="apple-mobile-web-app-title" content="Kid Videos" />
    <link rel="apple-touch-icon" href="/favicon.png" />
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Architects+Daughter&family=DM+Sans:ital,opsz,wght@0,9..40,100..1000;1,9..40,100..1000&family=Fira+Code:wght@300..700&family=Geist+Mono:wght@100..900&family=Geist:wght@100..900&family=IBM+Plex+Mono:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;1,100;1,200;1,300;1,400;1,500;1,600;1,700&family=IBM+Plex+Sans:ital,wght@0,100..700;1,100..700&family=Inter:ital,opsz,wght@0,14..32,100..900;1,14..32,100..900&family=JetBrains+Mono:ital,wght@0,100..800;1,100..800&family=Libre+Baskerville:ital,wght@0,400;0,700;1,400&family=Lora:ital,wght@0,400..700;1,400..700&family=Merriweather:ital,opsz,wght@0,18..144,300..900;1,18..144,300..900&family=Montserrat:ital,wght@0,100..900;1,100..900&family=Open+Sans:ital,wght@0,300..800;1,300..800&family=Outfit:wght@100..900&family=Oxanium:wght@200..800&family=Playfair+Display:ital,wght@0,400..900;1,400..900&family=Plus+Jakarta+Sans:ital,wght@0,200..800;1,200..800&family=Poppins:ital,wght@0,100;0,200;0,300;0,400;0,500;0,600;0,700;0,800;0,900;1,100;1,200;1,300;1,400;1,500;1,600;1,700;1,800;1,900&family=Roboto+Mono:ital,wght@0,100..700;1,100..700&family=Roboto:ital,wght@0,100..900;1,100..900&family=Source+Code+Pro:ital,wght@0,200..900;1,200..900&family=Source+Serif+4:ital,opsz,wght@0,8..60,200..900;1,8..60,200..900&family=Space+Grotesk:wght@300..700&family=Space+Mono:ital,wght@0,400;0,700;1,400;1,700&display=swap" rel="stylesheet">
  </head>
  <body>
    <div id="root"></div>
    <script type="module" src="/src/main.tsx"></script>
    <script>
      if ('serviceWorker' in navigator) {
        window.addEventListener('load', () => {
          navigator.serviceWorker.register('/sw.js').catch(() => {});
        });
      }
    </script>
  </body>
</html>

========================================
FILE: client/public/manifest.json
========================================
{
  "name": "Kid Video App",
  "short_name": "KidVideos",
  "description": "A safe way for kids to watch YouTube and TikTok videos",
  "display": "standalone",
  "background_color": "#ffffff",
  "theme_color": "#7c3aed",
  "orientation": "portrait-primary",
  "scope": "/",
  "icons": [
    {
      "src": "/favicon.png",
      "sizes": "192x192",
      "type": "image/png",
      "purpose": "any maskable"
    }
  ]
}


========================================
FILE: client/src/main.tsx
========================================
import { createRoot } from "react-dom/client";
import App from "./App";
import "./index.css";

createRoot(document.getElementById("root")!).render(<App />);


========================================
FILE: client/src/App.tsx
========================================
import { Switch, Route } from "wouter";
import { queryClient } from "./lib/queryClient";
import { QueryClientProvider } from "@tanstack/react-query";
import { Toaster } from "@/components/ui/toaster";
import { TooltipProvider } from "@/components/ui/tooltip";
import { useAuth } from "@/hooks/use-auth";
import Home from "@/pages/home";
import Landing from "@/pages/landing";
import NotFound from "@/pages/not-found";
import { Loader2 } from "lucide-react";

function AuthAwareRouter() {
  const { user, isLoading, isAuthenticated } = useAuth();

  if (isLoading) {
    return (
      <div className="min-h-screen flex items-center justify-center">
        <Loader2 className="w-8 h-8 animate-spin text-purple-500" />
      </div>
    );
  }

  if (!isAuthenticated) {
    return (
      <Switch>
        <Route path="/kid/:kidId" component={Home} />
        <Route path="/" component={Landing} />
        <Route component={NotFound} />
      </Switch>
    );
  }

  return (
    <Switch>
      <Route path="/kid/:kidId" component={Home} />
      <Route path="/" component={Home} />
      <Route component={NotFound} />
    </Switch>
  );
}

function App() {
  return (
    <QueryClientProvider client={queryClient}>
      <TooltipProvider>
        <Toaster />
        <AuthAwareRouter />
      </TooltipProvider>
    </QueryClientProvider>
  );
}

export default App;


========================================
FILE: client/src/index.css
========================================
@tailwind base;
@tailwind components;
@tailwind utilities;

/* LIGHT MODE - Kid-friendly, playful colors */
:root {
  --button-outline: rgba(0,0,0, .10);
  --badge-outline: rgba(0,0,0, .05);

  /* Automatic computation of border around primary / danger buttons */
  --opaque-button-border-intensity: -8; /* In terms of percentages */

  /* Backgrounds applied on top of other backgrounds when hovered/active */
  --elevate-1: rgba(0,0,0, .03);
  --elevate-2: rgba(0,0,0, .08);

  --background: 210 40% 98%;

  --foreground: 222 47% 11%;

  --border: 214 32% 91%;

  --card: 0 0% 100%;

  --card-foreground: 222 47% 11%;

  --card-border: 214 32% 91%;

  --sidebar: 262 83% 58%;

  --sidebar-foreground: 0 0% 100%;

  --sidebar-border: 262 83% 48%;

  --sidebar-primary: 280 100% 70%;

  --sidebar-primary-foreground: 0 0% 100%;

  --sidebar-accent: 280 100% 90%;

  --sidebar-accent-foreground: 262 83% 30%;

  --sidebar-ring: 262 83% 58%;

  --popover: 0 0% 100%;

  --popover-foreground: 222 47% 11%;

  --popover-border: 214 32% 91%;

  --primary: 262 83% 58%;

  --primary-foreground: 0 0% 100%;

  --secondary: 210 40% 96%;

  --secondary-foreground: 222 47% 11%;

  --muted: 210 40% 96%;

  --muted-foreground: 215 16% 47%;

  --accent: 43 96% 56%;

  --accent-foreground: 43 96% 16%;

  --destructive: 0 84% 60%;

  --destructive-foreground: 0 0% 100%;

  --input: 214 32% 91%;
  --ring: 262 83% 58%;
  --chart-1: 262 83% 58%;
  --chart-2: 173 80% 40%;
  --chart-3: 43 96% 56%;
  --chart-4: 280 100% 70%;
  --chart-5: 340 82% 52%;

  --font-sans: 'Poppins', sans-serif;
  --font-serif: Georgia, serif;
  --font-mono: Menlo, monospace;
  --radius: .75rem;
  --shadow-2xs: 0px 2px 4px 0px hsl(262 83% 58% / 0.08);
  --shadow-xs: 0px 2px 4px 0px hsl(262 83% 58% / 0.08);
  --shadow-sm: 0px 2px 8px 0px hsl(262 83% 58% / 0.08), 0px 1px 2px -1px hsl(262 83% 58% / 0.05);
  --shadow: 0px 4px 12px 0px hsl(262 83% 58% / 0.10), 0px 2px 4px -1px hsl(262 83% 58% / 0.08);
  --shadow-md: 0px 4px 16px 0px hsl(262 83% 58% / 0.12), 0px 2px 6px -1px hsl(262 83% 58% / 0.08);
  --shadow-lg: 0px 8px 24px 0px hsl(262 83% 58% / 0.14), 0px 4px 8px -1px hsl(262 83% 58% / 0.08);
  --shadow-xl: 0px 12px 32px 0px hsl(262 83% 58% / 0.16), 0px 8px 12px -1px hsl(262 83% 58% / 0.08);
  --shadow-2xl: 0px 16px 48px 0px hsl(262 83% 58% / 0.20);
  --tracking-normal: 0em;
  --spacing: 0.25rem;

  /* Automatically computed borders - intensity can be controlled by the user by the --opaque-button-border-intensity setting */

  /* Fallback for older browsers */
  --sidebar-primary-border: hsl(var(--sidebar-primary));
  --sidebar-primary-border: hsl(from hsl(var(--sidebar-primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --sidebar-accent-border: hsl(var(--sidebar-accent));
  --sidebar-accent-border: hsl(from hsl(var(--sidebar-accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --primary-border: hsl(var(--primary));
  --primary-border: hsl(from hsl(var(--primary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --secondary-border: hsl(var(--secondary));
  --secondary-border: hsl(from hsl(var(--secondary)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --muted-border: hsl(var(--muted));
  --muted-border: hsl(from hsl(var(--muted)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --accent-border: hsl(var(--accent));
  --accent-border: hsl(from hsl(var(--accent)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);

  /* Fallback for older browsers */
  --destructive-border: hsl(var(--destructive));
  --destructive-border: hsl(from hsl(var(--destructive)) h s calc(l + var(--opaque-button-border-intensity)) / alpha);
}

.dark {
  --button-outline: rgba(255,255,255, .10);
  --badge-outline: rgba(255,255,255, .05);

  --opaque-button-border-intensity: 9;  /* In terms of percentages */

  /* Backgrounds applied on top of other backgrounds when hovered/active */
  --elevate-1: rgba(255,255,255, .04);
  --elevate-2: rgba(255,255,255, .09);

  --background: 222 47% 11%;

  --foreground: 210 40% 98%;

  --border: 217 33% 17%;

  --card: 222 47% 14%;

  --card-foreground: 210 40% 98%;

  --card-border: 217 33% 20%;

  --sidebar: 262 83% 35%;

  --sidebar-foreground: 0 0% 100%;

  --sidebar-border: 262 83% 25%;

  --sidebar-primary: 280 100% 70%;

  --sidebar-primary-foreground: 0 0% 100%;

  --sidebar-accent: 262 83% 45%;

  --sidebar-accent-foreground: 0 0% 100%;

  --sidebar-ring: 262 83% 58%;

  --popover: 222 47% 14%;

  --popover-foreground: 210 40% 98%;

  --popover-border: 217 33% 20%;

  --primary: 262 83% 58%;

  --primary-foreground: 0 0% 100%;

  --secondary: 217 33% 17%;

  --secondary-foreground: 210 40% 98%;

  --muted: 217 33% 17%;

  --muted-foreground: 215 20% 65%;

  --accent: 43 96% 56%;

  --accent-foreground: 43 96% 10%;

  --destructive: 0 72% 51%;

  --destructive-foreground: 0 0% 100%;

  /* Used as the border around inputs. Dark mode: Should be a border that is light enough to have high contrast when rendered on a --card background. More contrast than standard --border */
  --input: 217 33% 25%;
  --ring: 262 83% 58%;
  --chart-1: 262 83% 58%;
  --chart-2: 173 80% 40%;
  --chart-3: 43 96% 56%;
  --chart-4: 280 100% 70%;
  --chart-5: 340 82% 52%;

  --shadow-2xs: 0px 2px 4px 0px hsl(0 0% 0% / 0.20);
  --shadow-xs: 0px 2px 4px 0px hsl(0 0% 0% / 0.20);
  --shadow-sm: 0px 2px 8px 0px hsl(0 0% 0% / 0.24), 0px 1px 2px -1px hsl(0 0% 0% / 0.16);
  --shadow: 0px 4px 12px 0px hsl(0 0% 0% / 0.28), 0px 2px 4px -1px hsl(0 0% 0% / 0.20);
  --shadow-md: 0px 4px 16px 0px hsl(0 0% 0% / 0.32), 0px 2px 6px -1px hsl(0 0% 0% / 0.24);
  --shadow-lg: 0px 8px 24px 0px hsl(0 0% 0% / 0.36), 0px 4px 8px -1px hsl(0 0% 0% / 0.28);
  --shadow-xl: 0px 12px 32px 0px hsl(0 0% 0% / 0.40), 0px 8px 12px -1px hsl(0 0% 0% / 0.32);
  --shadow-2xl: 0px 16px 48px 0px hsl(0 0% 0% / 0.48);

}

@layer base {
  * {
    @apply border-border;
  }

  body {
    @apply font-sans antialiased bg-background text-foreground;
  }
}

/**
 * Using the elevate system.
 * Automatic contrast adjustment.
 *
 * <element className="hover-elevate" />
 * <element className="active-elevate-2" />
 *
 * // Using the tailwind utility when a data attribute is "on"
 * <element className="toggle-elevate data-[state=on]:toggle-elevated" />
 * // Or manually controlling the toggle state
 * <element className="toggle-elevate toggle-elevated" />
 *
 * Elevation systems have to handle many states.
 * - not-hovered, vs. hovered vs. active  (three mutually exclusive states)
 * - toggled or not
 * - focused or not (this is not handled with these utilities)
 *
 * Even without handling focused or not, this is six possible combinations that
 * need to be distinguished from eachother visually.
 */
@layer utilities {

  /* Hide ugly search cancel button in Chrome until we can style it properly */
  input[type="search"]::-webkit-search-cancel-button {
    @apply hidden;
  }

  /* Placeholder styling for contentEditable div */
  [contenteditable][data-placeholder]:empty::before {
    content: attr(data-placeholder);
    color: hsl(var(--muted-foreground));
    pointer-events: none;
  }

  /* .no-default-hover-elevate/no-default-active-elevate is an escape hatch so consumers of
   * buttons/badges can remove the automatic brightness adjustment on interactions
   * and program their own. */
  .no-default-hover-elevate {}

  .no-default-active-elevate {}


  /**
   * Toggleable backgrounds go behind the content. Hoverable/active goes on top.
   * This way they can stack/compound. Both will overlap the parent's borders!
   * So borders will be automatically adjusted both on toggle, and hover/active,
   * and they will be compounded.
   */
  .toggle-elevate::before,
  .toggle-elevate-2::before {
    content: "";
    pointer-events: none;
    position: absolute;
    inset: 0px;
    /*border-radius: inherit;   match rounded corners */
    border-radius: inherit;
    z-index: -1;
    /* sits behind content but above backdrop */
  }

  .toggle-elevate.toggle-elevated::before {
    background-color: var(--elevate-2);
  }

  /* If there's a 1px border, adjust the inset so that it covers that parent's border */
  .border.toggle-elevate::before {
    inset: -1px;
  }

  /* Does not work on elements with overflow:hidden! */
  .hover-elevate:not(.no-default-hover-elevate),
  .active-elevate:not(.no-default-active-elevate),
  .hover-elevate-2:not(.no-default-hover-elevate),
  .active-elevate-2:not(.no-default-active-elevate) {
    position: relative;
    z-index: 0;
  }

  .hover-elevate:not(.no-default-hover-elevate)::after,
  .active-elevate:not(.no-default-active-elevate)::after,
  .hover-elevate-2:not(.no-default-hover-elevate)::after,
  .active-elevate-2:not(.no-default-active-elevate)::after {
    content: "";
    pointer-events: none;
    position: absolute;
    inset: 0px;
    /*border-radius: inherit;   match rounded corners */
    border-radius: inherit;
    z-index: 999;
    /* sits in front of content */
  }

  .hover-elevate:hover:not(.no-default-hover-elevate)::after,
  .active-elevate:active:not(.no-default-active-elevate)::after {
    background-color: var(--elevate-1);
  }

  .hover-elevate-2:hover:not(.no-default-hover-elevate)::after,
  .active-elevate-2:active:not(.no-default-active-elevate)::after {
    background-color: var(--elevate-2);
  }

  /* If there's a 1px border, adjust the inset so that it covers that parent's border */
  .border.hover-elevate:not(.no-hover-interaction-elevate)::after,
  .border.active-elevate:not(.no-active-interaction-elevate)::after,
  .border.hover-elevate-2:not(.no-hover-interaction-elevate)::after,
  .border.active-elevate-2:not(.no-active-interaction-elevate)::after,
  .border.hover-elevate:not(.no-hover-interaction-elevate)::after {
    inset: -1px;
  }
}


========================================
FILE: client/src/lib/utils.ts
========================================
import { clsx, type ClassValue } from "clsx"
import { twMerge } from "tailwind-merge"

export function cn(...inputs: ClassValue[]) {
  return twMerge(clsx(inputs))
}


========================================
FILE: client/src/lib/queryClient.ts
========================================
import { QueryClient, QueryFunction } from "@tanstack/react-query";

async function throwIfResNotOk(res: Response) {
  if (!res.ok) {
    const text = (await res.text()) || res.statusText;
    let message = text;
    try {
      const json = JSON.parse(text);
      if (json.error) message = json.error;
      else if (json.message) message = json.message;
    } catch {}
    throw new Error(message);
  }
}

export async function apiRequest(
  method: string,
  url: string,
  data?: unknown | undefined,
): Promise<Response> {
  const res = await fetch(url, {
    method,
    headers: data ? { "Content-Type": "application/json" } : {},
    body: data ? JSON.stringify(data) : undefined,
    credentials: "include",
  });

  await throwIfResNotOk(res);
  return res;
}

type UnauthorizedBehavior = "returnNull" | "throw";
export const getQueryFn: <T>(options: {
  on401: UnauthorizedBehavior;
}) => QueryFunction<T> =
  ({ on401: unauthorizedBehavior }) =>
  async ({ queryKey }) => {
    const res = await fetch(queryKey.join("/") as string, {
      credentials: "include",
    });

    if (unauthorizedBehavior === "returnNull" && res.status === 401) {
      return null;
    }

    await throwIfResNotOk(res);
    return await res.json();
  };

export const queryClient = new QueryClient({
  defaultOptions: {
    queries: {
      queryFn: getQueryFn({ on401: "throw" }),
      refetchInterval: false,
      refetchOnWindowFocus: false,
      staleTime: Infinity,
      retry: false,
    },
    mutations: {
      retry: false,
    },
  },
});


========================================
FILE: client/src/lib/auth-utils.ts
========================================
export function isUnauthorizedError(error: Error): boolean {
  return /^401: .*Unauthorized/.test(error.message);
}

// Redirect to login with a toast notification
export function redirectToLogin(toast?: (options: { title: string; description: string; variant: string }) => void) {
  if (toast) {
    toast({
      title: "Unauthorized",
      description: "You are logged out. Logging in again...",
      variant: "destructive",
    });
  }
  setTimeout(() => {
    window.location.href = "/api/login";
  }, 500);
}


========================================
FILE: client/src/hooks/use-auth.ts
========================================
import { useQuery, useMutation, useQueryClient } from "@tanstack/react-query";
import type { User } from "@shared/models/auth";

async function fetchUser(): Promise<User | null> {
  const response = await fetch("/api/auth/user", {
    credentials: "include",
  });

  if (response.status === 401) {
    return null;
  }

  if (!response.ok) {
    throw new Error(`${response.status}: ${response.statusText}`);
  }

  return response.json();
}

async function logout(): Promise<void> {
  window.location.href = "/api/logout";
}

export function useAuth() {
  const queryClient = useQueryClient();
  const { data: user, isLoading } = useQuery<User | null>({
    queryKey: ["/api/auth/user"],
    queryFn: fetchUser,
    retry: false,
    staleTime: 1000 * 60 * 5, // 5 minutes
  });

  const logoutMutation = useMutation({
    mutationFn: logout,
    onSuccess: () => {
      queryClient.setQueryData(["/api/auth/user"], null);
    },
  });

  return {
    user,
    isLoading,
    isAuthenticated: !!user,
    logout: logoutMutation.mutate,
    isLoggingOut: logoutMutation.isPending,
  };
}


========================================
FILE: client/src/hooks/use-toast.ts
========================================
import * as React from "react"

import type {
  ToastActionElement,
  ToastProps,
} from "@/components/ui/toast"

const TOAST_LIMIT = 1
const TOAST_REMOVE_DELAY = 1000000

type ToasterToast = ToastProps & {
  id: string
  title?: React.ReactNode
  description?: React.ReactNode
  action?: ToastActionElement
}

const actionTypes = {
  ADD_TOAST: "ADD_TOAST",
  UPDATE_TOAST: "UPDATE_TOAST",
  DISMISS_TOAST: "DISMISS_TOAST",
  REMOVE_TOAST: "REMOVE_TOAST",
} as const

let count = 0

function genId() {
  count = (count + 1) % Number.MAX_SAFE_INTEGER
  return count.toString()
}

type ActionType = typeof actionTypes

type Action =
  | {
      type: ActionType["ADD_TOAST"]
      toast: ToasterToast
    }
  | {
      type: ActionType["UPDATE_TOAST"]
      toast: Partial<ToasterToast>
    }
  | {
      type: ActionType["DISMISS_TOAST"]
      toastId?: ToasterToast["id"]
    }
  | {
      type: ActionType["REMOVE_TOAST"]
      toastId?: ToasterToast["id"]
    }

interface State {
  toasts: ToasterToast[]
}

const toastTimeouts = new Map<string, ReturnType<typeof setTimeout>>()

const addToRemoveQueue = (toastId: string) => {
  if (toastTimeouts.has(toastId)) {
    return
  }

  const timeout = setTimeout(() => {
    toastTimeouts.delete(toastId)
    dispatch({
      type: "REMOVE_TOAST",
      toastId: toastId,
    })
  }, TOAST_REMOVE_DELAY)

  toastTimeouts.set(toastId, timeout)
}

export const reducer = (state: State, action: Action): State => {
  switch (action.type) {
    case "ADD_TOAST":
      return {
        ...state,
        toasts: [action.toast, ...state.toasts].slice(0, TOAST_LIMIT),
      }

    case "UPDATE_TOAST":
      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === action.toast.id ? { ...t, ...action.toast } : t
        ),
      }

    case "DISMISS_TOAST": {
      const { toastId } = action

      // ! Side effects ! - This could be extracted into a dismissToast() action,
      // but I'll keep it here for simplicity
      if (toastId) {
        addToRemoveQueue(toastId)
      } else {
        state.toasts.forEach((toast) => {
          addToRemoveQueue(toast.id)
        })
      }

      return {
        ...state,
        toasts: state.toasts.map((t) =>
          t.id === toastId || toastId === undefined
            ? {
                ...t,
                open: false,
              }
            : t
        ),
      }
    }
    case "REMOVE_TOAST":
      if (action.toastId === undefined) {
        return {
          ...state,
          toasts: [],
        }
      }
      return {
        ...state,
        toasts: state.toasts.filter((t) => t.id !== action.toastId),
      }
  }
}

const listeners: Array<(state: State) => void> = []

let memoryState: State = { toasts: [] }

function dispatch(action: Action) {
  memoryState = reducer(memoryState, action)
  listeners.forEach((listener) => {
    listener(memoryState)
  })
}

type Toast = Omit<ToasterToast, "id">

function toast({ ...props }: Toast) {
  const id = genId()

  const update = (props: ToasterToast) =>
    dispatch({
      type: "UPDATE_TOAST",
      toast: { ...props, id },
    })
  const dismiss = () => dispatch({ type: "DISMISS_TOAST", toastId: id })

  dispatch({
    type: "ADD_TOAST",
    toast: {
      ...props,
      id,
      open: true,
      onOpenChange: (open) => {
        if (!open) dismiss()
      },
    },
  })

  return {
    id: id,
    dismiss,
    update,
  }
}

function useToast() {
  const [state, setState] = React.useState<State>(memoryState)

  React.useEffect(() => {
    listeners.push(setState)
    return () => {
      const index = listeners.indexOf(setState)
      if (index > -1) {
        listeners.splice(index, 1)
      }
    }
  }, [state])

  return {
    ...state,
    toast,
    dismiss: (toastId?: string) => dispatch({ type: "DISMISS_TOAST", toastId }),
  }
}

export { useToast, toast }


========================================
FILE: client/src/hooks/use-mobile.tsx
========================================
import * as React from "react"

const MOBILE_BREAKPOINT = 768

export function useIsMobile() {
  const [isMobile, setIsMobile] = React.useState<boolean | undefined>(undefined)

  React.useEffect(() => {
    const mql = window.matchMedia(`(max-width: ${MOBILE_BREAKPOINT - 1}px)`)
    const onChange = () => {
      setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    }
    mql.addEventListener("change", onChange)
    setIsMobile(window.innerWidth < MOBILE_BREAKPOINT)
    return () => mql.removeEventListener("change", onChange)
  }, [])

  return !!isMobile
}


========================================
FILE: client/src/pages/home.tsx
========================================
import { useState, useCallback, useMemo, useRef, useEffect } from "react";
import { useRoute } from "wouter";
import { useQuery, useMutation } from "@tanstack/react-query";
import { Card, CardContent, CardHeader, CardTitle } from "@/components/ui/card";
import { Button } from "@/components/ui/button";
import { Input } from "@/components/ui/input";
import { Badge } from "@/components/ui/badge";
import { Skeleton } from "@/components/ui/skeleton";
import { Checkbox } from "@/components/ui/checkbox";
import { Textarea } from "@/components/ui/textarea";
import { useToast } from "@/hooks/use-toast";
import { useAuth } from "@/hooks/use-auth";
import { queryClient, apiRequest } from "@/lib/queryClient";
import { 
  Play, Pause, Plus, Trash2, CheckCircle, Lock, ArrowLeft, User, Video, Sparkles, Star, Youtube, Loader2,
  Baby, Smile, PersonStanding, Glasses, Bot, Mic, MicOff, Eye, AlertTriangle, Settings, X, Volume2, Pencil, Check, Link, FolderPlus, Folder as FolderIcon, ChevronDown, ChevronRight, Music2, Clipboard, Download, LogOut, Square, RotateCcw, SkipForward, MessageSquare, Camera, Send, Image, Globe, Gift
} from "lucide-react";
import { SiTiktok } from "react-icons/si";
import {
  Dialog,
  DialogContent,
  DialogHeader,
  DialogTitle,
  DialogTrigger,
} from "@/components/ui/dialog";
import {
  AlertDialog,
  AlertDialogAction,
  AlertDialogCancel,
  AlertDialogContent,
  AlertDialogDescription,
  AlertDialogFooter,
  AlertDialogHeader,
  AlertDialogTitle,
} from "@/components/ui/alert-dialog";
import {
  Popover,
  PopoverContent,
  PopoverTrigger,
} from "@/components/ui/popover";
import { AVATARS, AVATAR_CONFIG, MAX_VIDEO_VIEWS, VIDEO_PRIORITY_DEFAULT, getVideoInfo } from "@shared/schema";
import type { Kid, Video as VideoType, VoiceRecording, Folder, VideoPlatform } from "@shared/schema";

// Safe avatar config getter with fallback
function getAvatarConfig(avatar: string) {
  return AVATAR_CONFIG[avatar as keyof typeof AVATAR_CONFIG] || { label: "Child", color: "from-purple-400 to-pink-400" };
}

// TikTok thumbnail component with caching
const tiktokThumbnailCache = new Map<string, string>();

function TikTokThumbnail({ videoId, className = "" }: { videoId: string; className?: string }) {
  const [thumbnailUrl, setThumbnailUrl] = useState<string | null>(tiktokThumbnailCache.get(videoId) || null);
  const [loading, setLoading] = useState(!tiktokThumbnailCache.has(videoId));
  const [error, setError] = useState(false);

  useEffect(() => {
    if (tiktokThumbnailCache.has(videoId)) {
      setThumbnailUrl(tiktokThumbnailCache.get(videoId)!);
      setLoading(false);
      return;
    }

    fetch(`/api/tiktok-thumbnail/${videoId}`)
      .then(res => res.ok ? res.json() : Promise.reject())
      .then(data => {
        if (data.thumbnailUrl) {
          tiktokThumbnailCache.set(videoId, data.thumbnailUrl);
          setThumbnailUrl(data.thumbnailUrl);
        } else {
          setError(true);
        }
      })
      .catch(() => setError(true))
      .finally(() => setLoading(false));
  }, [videoId]);

  if (loading) {
    return (
      <div className={`bg-gradient-to-br from-pink-500 via-red-500 to-cyan-500 flex items-center justify-center ${className}`}>
        <Loader2 className="w-5 h-5 text-white animate-spin" />
      </div>
    );
  }

  if (error || !thumbnailUrl) {
    return (
      <div className={`bg-gradient-to-br from-pink-500 via-red-500 to-cyan-500 flex items-center justify-center ${className}`}>
        <SiTiktok className="w-6 h-6 text-white" />
      </div>
    );
  }

  return (
    <img 
      src={thumbnailUrl} 
      alt="TikTok video thumbnail"
      className={`object-cover ${className}`}
      onError={() => setError(true)}
    />
  );
}

// Avatar icon component
function AvatarIcon({ avatar, className = "w-6 h-6" }: { avatar: string; className?: string }) {
  const iconProps = { className };
  switch (avatar) {
    case "child":
      return <PersonStanding {...iconProps} />;
    case "girl":
      return <Smile {...iconProps} />;
    case "boy":
      return <User {...iconProps} />;
    case "baby":
      return <Baby {...iconProps} />;
    case "cool":
      return <Glasses {...iconProps} />;
    case "robot":
      return <Bot {...iconProps} />;
    default:
      return <User {...iconProps} />;
  }
}

export default function Home() {
  const { toast } = useToast();
  
  // Check URL for direct kid mode (using route params like /kid/:kidId)
  const [isKidRoute, routeParams] = useRoute("/kid/:kidId");
  const kidParam = isKidRoute ? routeParams?.kidId : null;
  
  // Check URL path directly on initial load (for PWA/iOS compatibility)
  const getInitialKidId = () => {
    const path = window.location.pathname;
    const match = path.match(/^\/kid\/(.+)$/);
    if (match) {
      // Save to localStorage for PWA persistence
      localStorage.setItem('lockedKidId', match[1]);
      return match[1];
    }
    // Check if there's a saved kid from a previous PWA session
    const savedKidId = localStorage.getItem('lockedKidId');
    if (savedKidId) {
      return savedKidId;
    }
    return null;
  };
  
  const initialKidId = getInitialKidId();
  
  // Check if we should be in locked mode (from URL or saved PWA state)
  const isLockedKidMode = (isKidRoute && Boolean(kidParam)) || Boolean(localStorage.getItem('lockedKidId'));
  
  // App state - initialize based on URL path or saved PWA state
  const [mode, setMode] = useState<"parent" | "kid">(initialKidId ? "kid" : "parent");
  const [activeKidId, setActiveKidId] = useState<string>(initialKidId || "kid1");
  
  // Also sync mode when route hook updates (handles in-app navigation)
  useEffect(() => {
    if (isKidRoute && kidParam) {
      // Save to localStorage for PWA persistence
      localStorage.setItem('lockedKidId', kidParam);
      setMode("kid");
      setActiveKidId(kidParam);
    }
  }, [isKidRoute, kidParam]);
  
  // Parent forms
  const [newKidName, setNewKidName] = useState("");
  const [newKidAvatar, setNewKidAvatar] = useState<typeof AVATARS[number]>(AVATARS[0]);
  const [videoUrl, setVideoUrl] = useState("");
  const [selectedKidIds, setSelectedKidIds] = useState<string[]>([]); // empty = all kids
  const [assignToAll, setAssignToAll] = useState(true);
  const [videoPriority, setVideoPriority] = useState<number | null>(null);
  
  // Kid watch state
  const [watchingVideoId, setWatchingVideoId] = useState<string | null>(null);
  const [videoEnded, setVideoEnded] = useState(false);
  const [tiktokStarted, setTiktokStarted] = useState(false);
  const [watchProgress, setWatchProgress] = useState(0);
  const [videoDuration, setVideoDuration] = useState(0);
  const [elapsedSeconds, setElapsedSeconds] = useState(0);
  const [ytIsPlaying, setYtIsPlaying] = useState(false);
  const [ytCurrentTime, setYtCurrentTime] = useState(0);
  const [ytIsDragging, setYtIsDragging] = useState(false);
  const [ytDragValue, setYtDragValue] = useState(0);
  const ytWatchedTimeRef = useRef<number>(0);
  const ytLastTickRef = useRef<number>(0);
  const ytWaitTimerRef = useRef<NodeJS.Timeout | null>(null);
  const youtubePlayerRef = useRef<any>(null);
  const youtubeIframeRef = useRef<HTMLIFrameElement | null>(null);
  const youtubePlayerContainerRef = useRef<HTMLDivElement | null>(null);
  const ytTimerRef = useRef<NodeJS.Timeout | null>(null);
  const progressIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const tiktokStartTimeRef = useRef<number>(0);
  const videoStartTimeRef = useRef<number>(0);
  
  // Voice recording state
  const [isRecording, setIsRecording] = useState(false);
  const [hasRecording, setHasRecording] = useState(false);
  const [recordingDuration, setRecordingDuration] = useState(0);
  const [liveRecordingTime, setLiveRecordingTime] = useState(0);
  const [audioDataUrl, setAudioDataUrl] = useState<string | null>(null);
  const mediaRecorderRef = useRef<MediaRecorder | null>(null);
  const audioChunksRef = useRef<Blob[]>([]);
  const recordingStartTimeRef = useRef<number>(0);
  const recordingIntervalRef = useRef<NodeJS.Timeout | null>(null);
  
  // Settings dialog state
  const [settingsOpen, setSettingsOpen] = useState(false);
  const [editingKidId, setEditingKidId] = useState<string | null>(null);
  const [editingKidName, setEditingKidName] = useState("");
  
  // Folder state
  const [newFolderName, setNewFolderName] = useState("");
  const [selectedFolderId, setSelectedFolderId] = useState<string | null>(null);
  const [expandedFolders, setExpandedFolders] = useState<Set<string>>(new Set(["unfiled"]));
  
  // Video preview state
  const [previewingVideoId, setPreviewingVideoId] = useState<string | null>(null);
  
  // Delete confirmation state
  const [deletingFolderId, setDeletingFolderId] = useState<string | null>(null);
  const [deletingVideoId, setDeletingVideoId] = useState<string | null>(null);
  
  // Folder editing state
  const [editingFolderId, setEditingFolderId] = useState<string | null>(null);
  const [isFolderEditMode, setIsFolderEditMode] = useState(false);
  const [editingFolderName, setEditingFolderName] = useState("");
  
  // Add to home screen state
  const [showHomeScreenInstructions, setShowHomeScreenInstructions] = useState(false);
  const [deferredPrompt, setDeferredPrompt] = useState<any>(null);
  
  // Activity stats dialog state
  const [activityStatsKidId, setActivityStatsKidId] = useState<string | null>(null);
  
  // Activity detail view state (drilldown into specific time period)
  const [activityDetailView, setActivityDetailView] = useState<{
    kidId: string;
    period: 'today' | 'week' | 'month' | 'day';
    date?: Date; // for specific day from 7-day chart
  } | null>(null);
  
  // Audio playback state for activity detail
  const [playingAudioId, setPlayingAudioId] = useState<string | null>(null);
  const activityAudioRef = useRef<HTMLAudioElement | null>(null);
  
  // Auth
  const { user, isAuthenticated } = useAuth();
  
  // Feedback state
  const [feedbackOpen, setFeedbackOpen] = useState(false);
  const [feedbackType, setFeedbackType] = useState<'text' | 'voice' | 'video' | 'screenshot'>('text');
  const [feedbackText, setFeedbackText] = useState("");
  const [feedbackRecording, setFeedbackRecording] = useState(false);
  const [feedbackAudioData, setFeedbackAudioData] = useState<string | null>(null);
  const [feedbackAudioDuration, setFeedbackAudioDuration] = useState(0);
  const [feedbackScreenshot, setFeedbackScreenshot] = useState<string | null>(null);
  const [feedbackVideoUrl, setFeedbackVideoUrl] = useState("");
  const feedbackMediaRecorderRef = useRef<MediaRecorder | null>(null);
  const feedbackAudioChunksRef = useRef<Blob[]>([]);
  const feedbackRecordingStartRef = useRef<number>(0);
  const feedbackRecordingIntervalRef = useRef<NodeJS.Timeout | null>(null);
  const [feedbackLiveTime, setFeedbackLiveTime] = useState(0);

  // Global playlists state
  const [showGlobalPlaylists, setShowGlobalPlaylists] = useState(false);
  
  useEffect(() => {
    if (!isLockedKidMode) {
      fetch("/api/kids/cleanup-duplicates", { method: "POST", credentials: "include" })
        .then(r => r.ok ? r.json() : null)
        .then(data => {
          if (data?.removed > 0) {
            queryClient.invalidateQueries({ queryKey: ["/api/kids"] });
            queryClient.invalidateQueries({ queryKey: ["/api/videos"] });
          }
        })
        .catch(() => {});
    }
  }, [isLockedKidMode]);

  // Detect platform for home screen instructions
  const isIOS = /iPad|iPhone|iPod/.test(navigator.userAgent);
  const isAndroid = /Android/.test(navigator.userAgent);
  const isStandalone = window.matchMedia('(display-mode: standalone)').matches || (window.navigator as any).standalone;
  
  // Capture the beforeinstallprompt event for Android
  useEffect(() => {
    const handler = (e: Event) => {
      e.preventDefault();
      setDeferredPrompt(e);
    };
    window.addEventListener('beforeinstallprompt', handler);
    return () => window.removeEventListener('beforeinstallprompt', handler);
  }, []);
  
  // Handle Android install prompt
  const handleInstallClick = async () => {
    if (deferredPrompt) {
      deferredPrompt.prompt();
      const { outcome } = await deferredPrompt.userChoice;
      if (outcome === 'accepted') {
        toast({ title: "App installed!", description: "You can now open it from your home screen." });
      }
      setDeferredPrompt(null);
      setShowHomeScreenInstructions(false);
    } else if (isIOS) {
      // iOS doesn't support programmatic install, just show instructions
      setShowHomeScreenInstructions(true);
    } else {
      setShowHomeScreenInstructions(true);
    }
  };

  // Fetch kids - use public endpoint in kid mode
  const usePublicEndpoints = isLockedKidMode && !!initialKidId;
  const { data: kids = [], isLoading: kidsLoading } = useQuery<Kid[]>({
    queryKey: usePublicEndpoints
      ? ["/api/public/kid", initialKidId]
      : ["/api/kids"],
    ...(usePublicEndpoints ? {
      queryFn: async () => {
        const res = await fetch(`/api/public/kid/${initialKidId}`);
        if (!res.ok) return [];
        const kid = await res.json();
        return [kid];
      }
    } : {}),
    staleTime: 1000 * 30,
    refetchOnMount: "always",
  });

  // Fetch videos - use public endpoint in kid mode
  const { data: videos = [], isLoading: videosLoading } = useQuery<VideoType[]>({
    queryKey: usePublicEndpoints
      ? ["/api/public/kid", initialKidId, "videos"]
      : ["/api/videos"],
    ...(usePublicEndpoints ? {
      queryFn: async () => {
        const res = await fetch(`/api/public/kid/${initialKidId}/videos`);
        if (!res.ok) return [];
        return res.json();
      }
    } : {}),
    staleTime: 1000 * 30,
    refetchOnMount: "always",
  });

  // Fetch folders - use public endpoint in kid mode
  const { data: folders = [], isLoading: foldersLoading } = useQuery<Folder[]>({
    queryKey: usePublicEndpoints
      ? ["/api/public/kid", initialKidId, "folders"]
      : ["/api/folders"],
    ...(usePublicEndpoints ? {
      queryFn: async () => {
        const res = await fetch(`/api/public/kid/${initialKidId}/folders`);
        if (!res.ok) return [];
        return res.json();
      }
    } : {}),
    staleTime: 1000 * 30,
    refetchOnMount: "always",
  });

  // Global playlists queries (only for parent mode)
  const { data: isMasterData } = useQuery<{ isMaster: boolean }>({
    queryKey: ["/api/global/is-master"],
    enabled: !usePublicEndpoints,
    staleTime: 1000 * 60 * 5,
  });
  const isMaster = isMasterData?.isMaster || false;

  const { data: globalPlaylists = [] } = useQuery<(Folder & { videoCount: number })[]>({
    queryKey: ["/api/global/playlists"],
    enabled: !usePublicEndpoints,
    staleTime: 1000 * 60,
  });

  const { data: globalSubscriptions = [] } = useQuery<{ id: string; userId: string; masterFolderId: string; kidIds: string[] }[]>({
    queryKey: ["/api/global/subscriptions"],
    enabled: !usePublicEndpoints,
    staleTime: 1000 * 30,
  });

  const { data: trialStatus } = useQuery<{ daysLeft: number; show: boolean; frozen: boolean }>({
    queryKey: ["/api/trial-status"],
    enabled: !usePublicEndpoints,
    staleTime: 1000 * 60 * 60,
  });

  const subscribeMutation = useMutation({
    mutationFn: async ({ masterFolderId, kidIds }: { masterFolderId: string; kidIds: string[] }) => {
      const res = await apiRequest("POST", "/api/global/subscribe", { masterFolderId, kidIds });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/global/subscriptions"] });
      queryClient.invalidateQueries({ queryKey: ["/api/videos"] });
      queryClient.invalidateQueries({ queryKey: ["/api/folders"] });
      toast({ title: "Subscribed!", description: "Playlist videos added to your library." });
    },
    onError: () => {
      toast({ title: "Failed to subscribe", variant: "destructive" });
    },
  });

  const unsubscribeMutation = useMutation({
    mutationFn: async ({ masterFolderId }: { masterFolderId: string }) => {
      const res = await apiRequest("POST", "/api/global/unsubscribe", { masterFolderId });
      return res.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/global/subscriptions"] });
      queryClient.invalidateQueries({ queryKey: ["/api/videos"] });
      queryClient.invalidateQueries({ queryKey: ["/api/folders"] });
      toast({ title: "Unsubscribed", description: "Playlist removed from your library." });
    },
    onError: () => {
      toast({ title: "Failed to unsubscribe", variant: "destructive" });
    },
  });

  const activeKid = useMemo(() => 
    kids.find(k => k.id === activeKidId) || kids[0], 
    [kids, activeKidId]
  );

  // PWA badge: set home screen badge count
  useEffect(() => {
    if (!('setAppBadge' in navigator)) return;
    
    const setBadge = async () => {
      try {
        if (isLockedKidMode && initialKidId) {
          const res = await fetch(`/api/public/kid/${initialKidId}/badge`);
          if (res.ok) {
            const { count } = await res.json();
            if (count > 0) {
              (navigator as any).setAppBadge(count);
            } else {
              (navigator as any).clearAppBadge();
            }
          }
        } else if (mode === "parent" && kids.length > 0) {
          const res = await fetch('/api/badge/parent', { credentials: 'include' });
          if (res.ok) {
            const { count } = await res.json();
            if (count > 0) {
              (navigator as any).setAppBadge(count);
            } else {
              (navigator as any).clearAppBadge();
            }
          }
        }
      } catch {}
    };
    
    setBadge();
  }, [isLockedKidMode, initialKidId, mode, videos, kids]);

  // Auto-clear parent badge when parent views the home screen
  useEffect(() => {
    if (mode !== "parent" || isLockedKidMode) return;
    
    const clearBadge = async () => {
      try {
        await fetch('/api/badge/parent/clear', { method: 'POST', credentials: 'include' });
        if ('clearAppBadge' in navigator) {
          (navigator as any).clearAppBadge();
        }
      } catch {}
    };
    
    const timeout = setTimeout(clearBadge, 3000);
    return () => clearTimeout(timeout);
  }, [mode, isLockedKidMode]);

  // Get videos assigned to active kid
  const assignedVideos = useMemo(() => 
    videos.filter(v => v.assigned?.[activeKid?.id]), 
    [videos, activeKid]
  );

  // Group assigned videos by folder for kid view (sorted by priority)
  const kidVideosByFolder = useMemo(() => {
    const groups: { id: string; name: string; videos: typeof assignedVideos }[] = [];
    
    // Group by folder
    const folderMap = new Map<string | null, typeof assignedVideos>();
    assignedVideos.forEach(video => {
      const folderId = video.folderId ?? null;
      if (!folderMap.has(folderId)) {
        folderMap.set(folderId, []);
      }
      folderMap.get(folderId)!.push(video);
    });
    
    // Add folder groups (sort videos by priority)
    folders.forEach(folder => {
      const folderVideos = folderMap.get(folder.id) || [];
      if (folderVideos.length > 0) {
        const sortedVideos = [...folderVideos].sort((a, b) => (a.priority || 5) - (b.priority || 5));
        const globalMatch = folder.name.match(/^__global_(.+)$/);
        const masterPlaylist = globalMatch ? globalPlaylists.find(gp => gp.id === globalMatch[1]) : null;
        const displayName = masterPlaylist ? masterPlaylist.name : (globalMatch ? "Curated Playlist" : folder.name);
        groups.push({ id: folder.id, name: displayName, videos: sortedVideos });
      }
    });
    
    // Add unfiled videos (also sorted by priority)
    const unfiledVideos = folderMap.get(null) || [];
    if (unfiledVideos.length > 0) {
      const sortedUnfiled = [...unfiledVideos].sort((a, b) => (a.priority || 5) - (b.priority || 5));
      groups.push({ id: "unfiled", name: "Other Videos", videos: sortedUnfiled });
    }
    
    return groups;
  }, [assignedVideos, folders, globalPlaylists]);

  // Check if a video is locked (requires lower priority videos to be watched first)
  const isVideoLocked = useCallback((video: VideoType, folderVideos: VideoType[], kidId: string) => {
    const videoPriority = video.priority || 5;
    // Find all videos with lower priority that haven't been watched
    const unwatchedLowerPriority = folderVideos.filter(v => {
      const vPriority = v.priority || 5;
      return vPriority < videoPriority && !v.progress?.[kidId]?.watched;
    });
    return unwatchedLowerPriority.length > 0;
  }, []);

  // Get stats for a kid
  const getKidStats = useCallback((kidId: string) => {
    const assigned = videos.filter(v => v.assigned?.[kidId]);
    const watched = assigned.filter(v => v.progress?.[kidId]?.watched).length;
    return { watched, pending: assigned.length - watched, total: assigned.length };
  }, [videos]);

  // Get detailed activity stats for a kid (daily, weekly, monthly)
  const getDetailedActivityStats = useCallback((kidId: string) => {
    const now = new Date();
    const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const startOfWeek = new Date(startOfToday);
    startOfWeek.setDate(startOfWeek.getDate() - 6);
    const startOfMonth = new Date(now.getFullYear(), now.getMonth(), 1);
    
    const assigned = videos.filter(v => v.assigned?.[kidId]);
    const totalAssigned = assigned.length;
    
    // Count ALL watched videos (including legacy data without timestamps)
    const allWatchedVideos = assigned.filter(v => v.progress?.[kidId]?.watched);
    const totalCompleted = allWatchedVideos.length;
    
    // Get completed videos WITH timestamps for time-based breakdown
    const datedCompletions = allWatchedVideos
      .filter(v => v.progress?.[kidId]?.watchedAt)
      .map(v => ({
        video: v,
        watchedAt: new Date(v.progress[kidId].watchedAt!)
      }));
    
    // Count legacy completions without dates
    const undatedCompletions = totalCompleted - datedCompletions.length;
    
    // Filter by time periods (only dated completions)
    const completedToday = datedCompletions.filter(c => c.watchedAt >= startOfToday).length;
    const completedThisWeek = datedCompletions.filter(c => c.watchedAt >= startOfWeek).length;
    const completedThisMonth = datedCompletions.filter(c => c.watchedAt >= startOfMonth).length;
    
    // Get recent activity (last 7 days breakdown)
    const last7Days: { date: string; count: number }[] = [];
    for (let i = 6; i >= 0; i--) {
      const date = new Date(startOfToday);
      date.setDate(date.getDate() - i);
      const nextDate = new Date(date);
      nextDate.setDate(nextDate.getDate() + 1);
      const count = datedCompletions.filter(c => c.watchedAt >= date && c.watchedAt < nextDate).length;
      last7Days.push({
        date: date.toLocaleDateString('en-US', { weekday: 'short', month: 'short', day: 'numeric' }),
        count
      });
    }
    
    return {
      totalAssigned,
      totalCompleted,
      pending: totalAssigned - totalCompleted,
      completedToday,
      completedThisWeek,
      completedThisMonth,
      last7Days,
      undatedCompletions,
      completionRate: totalAssigned > 0 ? Math.round((totalCompleted / totalAssigned) * 100) : 0
    };
  }, [videos]);

  // Get videos watched in a specific time period for a kid
  const getVideosForPeriod = useCallback((kidId: string, period: 'today' | 'week' | 'month' | 'day', specificDate?: Date) => {
    const now = new Date();
    const startOfToday = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    
    let startDate: Date;
    let endDate: Date = new Date(startOfToday.getTime() + 24 * 60 * 60 * 1000); // end of today
    
    if (period === 'today') {
      startDate = startOfToday;
    } else if (period === 'week') {
      startDate = new Date(startOfToday);
      startDate.setDate(startDate.getDate() - startDate.getDay());
    } else if (period === 'month') {
      startDate = new Date(now.getFullYear(), now.getMonth(), 1);
    } else if (period === 'day' && specificDate) {
      startDate = new Date(specificDate.getFullYear(), specificDate.getMonth(), specificDate.getDate());
      endDate = new Date(startDate.getTime() + 24 * 60 * 60 * 1000);
    } else {
      startDate = startOfToday;
    }
    
    const assigned = videos.filter(v => v.assigned?.[kidId]);
    const watchedVideos = assigned
      .filter(v => {
        const progress = v.progress?.[kidId];
        if (!progress?.watched || !progress?.watchedAt) return false;
        const watchedAt = new Date(progress.watchedAt);
        return watchedAt >= startDate && watchedAt < endDate;
      })
      .sort((a, b) => {
        const aDate = new Date(a.progress?.[kidId]?.watchedAt || 0);
        const bDate = new Date(b.progress?.[kidId]?.watchedAt || 0);
        return bDate.getTime() - aDate.getTime(); // Latest first
      });
    
    return watchedVideos;
  }, [videos]);

  // Create kid mutation
  const createKidMutation = useMutation({
    mutationFn: async (data: { name: string; avatar: typeof AVATARS[number] }) => {
      const response = await apiRequest("POST", "/api/kids", data);
      return response.json();
    },
    onSuccess: (kid: Kid) => {
      queryClient.invalidateQueries({ queryKey: ["/api/kids"] });
      queryClient.invalidateQueries({ queryKey: ["/api/videos"] });
      setNewKidName("");
      setNewKidAvatar(AVATARS[0]);
      toast({ title: "Kid added!", description: `${kid.name} has been added successfully.` });
    },
    onError: (error: any) => {
      toast({ title: "Error", description: error?.message || "Failed to add kid.", variant: "destructive" });
    },
  });

  // Update kid mutation
  const updateKidMutation = useMutation({
    mutationFn: async ({ id, name }: { id: string; name: string }) => {
      const response = await apiRequest("PATCH", `/api/kids/${id}`, { name });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/kids"] });
      setEditingKidId(null);
      setEditingKidName("");
      toast({ title: "Name updated!" });
    },
    onError: () => {
      toast({ title: "Error", description: "Failed to update name.", variant: "destructive" });
    },
  });

  // Delete kid mutation
  const deleteKidMutation = useMutation({
    mutationFn: async (id: string) => {
      await apiRequest("DELETE", `/api/kids/${id}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/kids"] });
      queryClient.invalidateQueries({ queryKey: ["/api/videos"] });
      toast({ title: "Kid removed" });
    },
    onError: () => {
      toast({ title: "Error", description: "Failed to remove kid.", variant: "destructive" });
    },
  });

  // Create folder mutation
  const createFolderMutation = useMutation({
    mutationFn: async ({ name }: { name: string }) => {
      const response = await apiRequest("POST", "/api/folders", { name });
      return response.json();
    },
    onSuccess: (folder: Folder) => {
      queryClient.invalidateQueries({ queryKey: ["/api/folders"] });
      setNewFolderName("");
      setExpandedFolders(prev => new Set([...Array.from(prev), folder.id]));
      toast({ title: "Folder created!", description: `"${folder.name}" folder has been added.` });
    },
    onError: () => {
      toast({ title: "Error", description: "Failed to create folder.", variant: "destructive" });
    },
  });

  // Delete folder mutation
  const deleteFolderMutation = useMutation({
    mutationFn: async (id: string) => {
      await apiRequest("DELETE", `/api/folders/${id}`);
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/folders"] });
      queryClient.invalidateQueries({ queryKey: ["/api/videos"] }); // Videos may have changed folderId
      setSelectedFolderId(null);
      setDeletingFolderId(null);
      toast({ title: "Folder deleted" });
    },
    onError: () => {
      setDeletingFolderId(null);
      toast({ title: "Error", description: "Failed to delete folder.", variant: "destructive" });
    },
  });

  // Update folder mutation
  const updateFolderMutation = useMutation({
    mutationFn: async ({ id, name }: { id: string; name: string }) => {
      const response = await apiRequest("PATCH", `/api/folders/${id}`, { name });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/folders"] });
      setEditingFolderId(null);
      setEditingFolderName("");
      toast({ title: "Folder renamed!" });
    },
    onError: () => {
      toast({ title: "Error", description: "Failed to rename folder.", variant: "destructive" });
    },
  });

  // Create video mutation
  const createVideoMutation = useMutation({
    mutationFn: async ({ url, kidIds, folderId, priority }: { url: string; kidIds?: string[]; folderId?: string | null; priority?: number }) => {
      const response = await apiRequest("POST", "/api/videos", { url, kidIds, folderId, priority });
      return response.json();
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/videos"] });
      setVideoUrl("");
      setSelectedKidIds([]);
      setAssignToAll(true);
      setVideoPriority(null);
      const desc = assignToAll ? "The video has been added for all kids." : "The video has been added for selected kids.";
      toast({ title: "Video added!", description: desc });
    },
    onError: () => {
      toast({ title: "Error", description: "Failed to add video. Check if the URL is valid.", variant: "destructive" });
    },
  });

  // Delete video mutation
  const deleteVideoMutation = useMutation({
    mutationFn: async (videoId: string) => {
      await apiRequest("DELETE", `/api/videos/${videoId}`);
    },
    onSuccess: (_, videoId) => {
      queryClient.invalidateQueries({ queryKey: ["/api/videos"] });
      // Close preview if this video was being previewed
      if (previewingVideoId === videoId) {
        setPreviewingVideoId(null);
      }
      setDeletingVideoId(null);
      toast({ title: "Video removed", description: "The video has been removed from the library." });
    },
    onError: () => {
      setDeletingVideoId(null);
      toast({ title: "Error", description: "Failed to delete video.", variant: "destructive" });
    },
  });

  // Update video mutation (priority, folder)
  const updateVideoMutation = useMutation({
    mutationFn: async ({ videoId, priority, folderId }: { videoId: string; priority?: number; folderId?: string | null }) => {
      await apiRequest("PATCH", `/api/videos/${videoId}`, { priority, folderId });
    },
    onSuccess: () => {
      queryClient.invalidateQueries({ queryKey: ["/api/videos"] });
    },
    onError: () => {
      toast({ title: "Error", description: "Failed to update video.", variant: "destructive" });
    },
  });

  // Mark video watched mutation (requires voice recording)
  const markWatchedMutation = useMutation({
    mutationFn: async ({ videoId, kidId, voiceRecording }: { videoId: string; kidId: string; voiceRecording: VoiceRecording }) => {
      if (isLockedKidMode && initialKidId) {
        const res = await fetch(`/api/public/kid/${initialKidId}/videos/${videoId}/watched`, {
          method: "POST",
          headers: { "Content-Type": "application/json" },
          body: JSON.stringify({ voiceRecording }),
        });
        if (!res.ok) {
          const err = await res.json().catch(() => ({ error: "Failed" }));
          throw new Error(err.error || "Failed to mark video as watched");
        }
        return res.json();
      }
      const response = await apiRequest("POST", `/api/videos/${videoId}/watched/${kidId}`, { voiceRecording });
      return response.json();
    },
    onSuccess: () => {
      if (isLockedKidMode && initialKidId) {
        queryClient.invalidateQueries({ queryKey: ["/api/public/kid", initialKidId, "videos"] });
      } else {
        queryClient.invalidateQueries({ queryKey: ["/api/videos"] });
      }
      setWatchingVideoId(null);
      setVideoEnded(false);
      setHasRecording(false);
      setRecordingDuration(0);
      toast({ title: "Great job!", description: "Video completed! Keep up the good work!" });
    },
    onError: (error: Error) => {
      const msg = error.message || "Failed to mark video as completed.";
      toast({ title: "Error", description: msg, variant: "destructive" });
    },
  });

  // Feedback mutation
  const feedbackMutation = useMutation({
    mutationFn: async (data: { type: string; content: string }) => {
      const response = await apiRequest("POST", "/api/feedback", data);
      return response.json();
    },
    onSuccess: () => {
      toast({ title: "Thank you!", description: "Your feedback has been submitted." });
      setFeedbackOpen(false);
      resetFeedbackForm();
    },
    onError: () => {
      toast({ title: "Error", description: "Failed to submit feedback. Please try again.", variant: "destructive" });
    },
  });

  // Reset feedback form
  const resetFeedbackForm = useCallback(() => {
    setFeedbackType('text');
    setFeedbackText("");
    setFeedbackAudioData(null);
    setFeedbackAudioDuration(0);
    setFeedbackScreenshot(null);
    setFeedbackVideoUrl("");
    setFeedbackRecording(false);
    setFeedbackLiveTime(0);
  }, []);

  // Feedback voice recording
  const startFeedbackRecording = useCallback(async () => {
    try {
      const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
      const mediaRecorder = new MediaRecorder(stream);
      feedbackMediaRecorderRef.current = mediaRecorder;
      feedbackAudioChunksRef.current = [];

      mediaRecorder.ondataavailable = (e) => {
        if (e.data.size > 0) feedbackAudioChunksRef.current.push(e.data);
      };

      mediaRecorder.onstop = () => {
        const audioBlob = new Blob(feedbackAudioChunksRef.current, { type: 'audio/webm' });
        const reader = new FileReader();
        reader.onloadend = () => {
          setFeedbackAudioData(reader.result as string);
        };
        reader.readAsDataURL(audioBlob);
        stream.getTracks().forEach(track => track.stop());
      };

      feedbackRecordingStartRef.current = Date.now();
      setFeedbackLiveTime(0);
      feedbackRecordingIntervalRef.current = setInterval(() => {
        setFeedbackLiveTime(Math.floor((Date.now() - feedbackRecordingStartRef.current) / 1000));
      }, 100);

      mediaRecorder.start();
      setFeedbackRecording(true);
    } catch (error) {
      toast({ title: "Microphone error", description: "Could not access microphone.", variant: "destructive" });
    }
  }, [toast]);

  const stopFeedbackRecording = useCallback(() => {
    if (feedbackMediaRecorderRef.current && feedbackRecording) {
      feedbackMediaRecorderRef.current.stop();
      setFeedbackRecording(false);
      if (feedbackRecordingIntervalRef.current) {
        clearInterval(feedbackRecordingIntervalRef.current);
      }
      setFeedbackAudioDuration(Math.floor((Date.now() - feedbackRecordingStartRef.current) / 1000));
    }
  }, [feedbackRecording]);

  // Handle screenshot upload
  const handleScreenshotUpload = useCallback((e: React.ChangeEvent<HTMLInputElement>) => {
    const file = e.target.files?.[0];
    if (file) {
      const reader = new FileReader();
      reader.onloadend = () => {
        setFeedbackScreenshot(reader.result as string);
      };
      reader.readAsDataURL(file);
    }
  }, []);

  // Submit feedback
  const submitFeedback = useCallback(() => {
    let content = "";
    if (feedbackType === 'text') {
      content = feedbackText.trim();
      if (!content) {
        toast({ title: "Missing feedback", description: "Please enter your feedback.", variant: "destructive" });
        return;
      }
    } else if (feedbackType === 'voice') {
      if (!feedbackAudioData) {
        toast({ title: "Missing recording", description: "Please record your feedback.", variant: "destructive" });
        return;
      }
      content = feedbackAudioData;
    } else if (feedbackType === 'screenshot') {
      if (!feedbackScreenshot) {
        toast({ title: "Missing screenshot", description: "Please upload a screenshot.", variant: "destructive" });
        return;
      }
      content = feedbackScreenshot;
    } else if (feedbackType === 'video') {
      content = feedbackVideoUrl.trim();
      if (!content) {
        toast({ title: "Missing video link", description: "Please paste a video link.", variant: "destructive" });
        return;
      }
    }
    feedbackMutation.mutate({ type: feedbackType, content });
  }, [feedbackType, feedbackText, feedbackAudioData, feedbackScreenshot, feedbackVideoUrl, feedbackMutation, toast]);

  // Add a new kid
  const addKid = useCallback(() => {
    const name = newKidName.trim();
    if (!name) {
      toast({ title: "Missing name", description: "Please enter a name for the kid.", variant: "destructive" });
      return;
    }
    if (kids.length >= 6) {
      toast({ title: "Limit reached", description: "You can add up to 6 kids.", variant: "destructive" });
      return;
    }
    createKidMutation.mutate({ name, avatar: newKidAvatar });
  }, [newKidName, newKidAvatar, kids.length, toast, createKidMutation]);

  // Add a new folder
  const addFolder = useCallback(() => {
    const name = newFolderName.trim();
    if (!name) {
      toast({ title: "Missing name", description: "Please enter a folder name.", variant: "destructive" });
      return;
    }
    createFolderMutation.mutate({ name });
  }, [newFolderName, toast, createFolderMutation]);

  // Add a new video
  // Check if URL is a TikTok short link that needs resolution
  const isTikTokShortUrl = useCallback((url: string): boolean => {
    try {
      const u = new URL(url);
      const host = u.hostname.replace('www.', '').toLowerCase();
      return host === 'vm.tiktok.com' || (host === 'tiktok.com' && u.pathname.startsWith('/t/'));
    } catch {
      return false;
    }
  }, []);

  // State for resolving TikTok URLs
  const [isResolvingUrl, setIsResolvingUrl] = useState(false);

  const addVideo = useCallback(async () => {
    let normalized = videoUrl.trim();
    if (!normalized) {
      toast({ title: "Missing link", description: "Please paste a YouTube or TikTok link.", variant: "destructive" });
      return;
    }
    
    // Check if it's a TikTok short URL that needs resolution
    if (isTikTokShortUrl(normalized)) {
      setIsResolvingUrl(true);
      try {
        const response = await apiRequest("POST", "/api/resolve-tiktok-url", { url: normalized });
        const data = await response.json();
        if (data.resolvedUrl) {
          normalized = data.resolvedUrl;
          setVideoUrl(normalized); // Update the input with resolved URL
          toast({ title: "Link resolved!", description: "TikTok short link converted to full URL." });
        } else {
          toast({ title: "Invalid link", description: "Could not resolve TikTok short link.", variant: "destructive" });
          setIsResolvingUrl(false);
          return;
        }
      } catch {
        toast({ title: "Error", description: "Could not resolve TikTok short link. Please use the full TikTok URL.", variant: "destructive" });
        setIsResolvingUrl(false);
        return;
      }
      setIsResolvingUrl(false);
    }
    
    const videoInfo = getVideoInfo(normalized);
    if (!videoInfo) {
      toast({ title: "Invalid link", description: "Please paste a valid YouTube or TikTok link.", variant: "destructive" });
      return;
    }

    // Check if folder is selected
    if (selectedFolderId === null) {
      toast({ title: "No folder selected", description: "Please select a folder for this video.", variant: "destructive" });
      return;
    }

    // Check if priority level is selected
    if (videoPriority === null) {
      toast({ title: "No level selected", description: "Please select a priority level (1-9).", variant: "destructive" });
      return;
    }

    // Check if specific kids selected
    if (!assignToAll && selectedKidIds.length === 0) {
      toast({ title: "No kids selected", description: "Please select at least one kid or choose 'All Kids'.", variant: "destructive" });
      return;
    }

    const kidIds = assignToAll ? undefined : selectedKidIds;
    const folderId = selectedFolderId === "unfiled" ? null : selectedFolderId;
    createVideoMutation.mutate({ url: normalized, kidIds, folderId, priority: videoPriority });
  }, [videoUrl, toast, createVideoMutation, assignToAll, selectedKidIds, selectedFolderId, videoPriority, isTikTokShortUrl]);

  // Paste video URL from clipboard - always focus input first, then try clipboard
  const pasteFromClipboard = useCallback(async () => {
    // Focus input immediately (synchronous, within user gesture)
    const input = document.querySelector('[data-testid="input-video-url"]') as HTMLInputElement;
    if (input) {
      input.focus();
    }
    
    // Now try to read clipboard and paste
    try {
      if (navigator.clipboard && navigator.clipboard.readText) {
        const text = await navigator.clipboard.readText();
        if (text && text.trim()) {
          setVideoUrl(text.trim());
        }
      }
    } catch {
      // Clipboard API failed - input is already focused for manual paste
    }
  }, []);

  // Start editing a folder name
  const startEditingFolder = useCallback((folder: Folder) => {
    setEditingFolderId(folder.id);
    setEditingFolderName(folder.name);
  }, []);

  // Save edited folder name
  const saveEditingFolder = useCallback(() => {
    if (!editingFolderId) return;
    const name = editingFolderName.trim();
    if (!name) {
      toast({ title: "Name required", description: "Please enter a folder name.", variant: "destructive" });
      return;
    }
    updateFolderMutation.mutate({ id: editingFolderId, name });
  }, [editingFolderId, editingFolderName, toast, updateFolderMutation]);

  // Cancel editing folder
  const cancelEditingFolder = useCallback(() => {
    setEditingFolderId(null);
    setEditingFolderName("");
  }, []);

  // Toggle folder expansion
  const toggleFolder = useCallback((folderId: string) => {
    setExpandedFolders(prev => {
      const next = new Set(prev);
      if (next.has(folderId)) {
        next.delete(folderId);
      } else {
        next.add(folderId);
      }
      return next;
    });
  }, []);

  // Remove a video (triggers confirmation dialog)
  const removeVideo = useCallback((videoId: string) => {
    setDeletingVideoId(videoId);
  }, []);

  // Load YouTube IFrame API
  useEffect(() => {
    if ((window as any).YT) return;
    const tag = document.createElement('script');
    tag.src = 'https://www.youtube.com/iframe_api';
    document.head.appendChild(tag);
  }, []);

  // Create YouTube player when watching a YouTube video in kid mode
  useEffect(() => {
    if (mode !== 'kid' || !watchingVideoId) return;
    const watchingVideo = videos.find(v => v.id === watchingVideoId);
    if (!watchingVideo || watchingVideo.platform !== 'youtube') return;

    ytWatchedTimeRef.current = 0;
    ytLastTickRef.current = 0;

    const createPlayer = () => {
      if (!youtubePlayerContainerRef.current) return;
      if (youtubePlayerRef.current) {
        try { youtubePlayerRef.current.destroy(); } catch {}
        youtubePlayerRef.current = null;
      }

      const viewCount = watchingVideo.totalViews || 0;
      const isFirstWatch = viewCount === 0;
      const requiredPercent = isFirstWatch ? 90 : 60;

      youtubePlayerRef.current = new (window as any).YT.Player(youtubePlayerContainerRef.current, {
        videoId: watchingVideo.ytId,
        playerVars: {
          playsinline: 1,
          controls: 0,
          rel: 0,
          fs: 0,
          modestbranding: 1,
          disablekb: 1,
          autoplay: 1,
        },
        events: {
          onReady: (event: any) => {
            const dur = event.target.getDuration() || 0;
            setVideoDuration(dur);
            event.target.playVideo();
            ytLastTickRef.current = Date.now();

            if (ytTimerRef.current) clearInterval(ytTimerRef.current);
            ytTimerRef.current = setInterval(() => {
              const p = youtubePlayerRef.current;
              if (!p || typeof p.getCurrentTime !== 'function') return;
              const cur = p.getCurrentTime() || 0;
              const d = p.getDuration() || dur;
              setYtCurrentTime(cur);
              setVideoDuration(d);

              const state = p.getPlayerState?.();
              const isPlaying = state === (window as any).YT.PlayerState.PLAYING;
              const now = Date.now();
              if (isPlaying) {
                ytWatchedTimeRef.current += (now - ytLastTickRef.current) / 1000;
              }
              ytLastTickRef.current = now;

              const watchedSec = Math.floor(ytWatchedTimeRef.current);
              setElapsedSeconds(watchedSec);
              const requiredSec = Math.ceil((d * requiredPercent) / 100);
              const progress = requiredSec > 0 ? Math.min(100, Math.floor((watchedSec / requiredSec) * 100)) : 0;
              setWatchProgress(progress);

              if (progress >= 100) {
                setVideoEnded(prev => {
                  if (!prev) return true;
                  return prev;
                });
              }
            }, 300);
          },
          onStateChange: (event: any) => {
            const state = event.data;
            const playing = state === (window as any).YT.PlayerState.PLAYING;
            setYtIsPlaying(playing);
            if (playing) {
              ytLastTickRef.current = Date.now();
            }
          },
        },
      });
    };

    let cancelled = false;
    const waitForYT = () => {
      if (cancelled) return;
      if ((window as any).YT && (window as any).YT.Player) {
        ytWaitTimerRef.current = setTimeout(createPlayer, 100);
      } else {
        ytWaitTimerRef.current = setTimeout(waitForYT, 200);
      }
    };
    waitForYT();

    return () => {
      cancelled = true;
      if (ytWaitTimerRef.current) {
        clearTimeout(ytWaitTimerRef.current);
        ytWaitTimerRef.current = null;
      }
      if (ytTimerRef.current) {
        clearInterval(ytTimerRef.current);
        ytTimerRef.current = null;
      }
      if (youtubePlayerRef.current) {
        try { youtubePlayerRef.current.destroy(); } catch {}
        youtubePlayerRef.current = null;
      }
    };
  }, [mode, watchingVideoId, videos]);

  // Start watching a video
  const startWatch = useCallback((videoId: string) => {
    setWatchingVideoId(videoId);
    setVideoEnded(false);
    setYtIsPlaying(false);
    setYtCurrentTime(0);
    setVideoDuration(0);
    setYtIsDragging(false);
  }, []);

  // Voice recording functions - tap to start/stop
  const toggleRecording = useCallback(async () => {
    if (isRecording) {
      // Stop recording
      if (mediaRecorderRef.current) {
        mediaRecorderRef.current.stop();
        setIsRecording(false);
        if (recordingIntervalRef.current) {
          clearInterval(recordingIntervalRef.current);
          recordingIntervalRef.current = null;
        }
      }
    } else {
      // Start recording - pause video first
      if (youtubePlayerRef.current && typeof youtubePlayerRef.current.pauseVideo === 'function') {
        youtubePlayerRef.current.pauseVideo();
      }
      
      try {
        const stream = await navigator.mediaDevices.getUserMedia({ audio: true });
        
        // Detect best supported audio format (iOS needs mp4/aac, others prefer webm)
        let mimeType = 'audio/webm';
        if (MediaRecorder.isTypeSupported('audio/mp4')) {
          mimeType = 'audio/mp4';
        } else if (MediaRecorder.isTypeSupported('audio/webm;codecs=opus')) {
          mimeType = 'audio/webm;codecs=opus';
        } else if (MediaRecorder.isTypeSupported('audio/webm')) {
          mimeType = 'audio/webm';
        } else if (MediaRecorder.isTypeSupported('audio/ogg')) {
          mimeType = 'audio/ogg';
        }
        
        const mediaRecorder = new MediaRecorder(stream, { mimeType });
        mediaRecorderRef.current = mediaRecorder;
        audioChunksRef.current = [];
        recordingStartTimeRef.current = Date.now();
        setLiveRecordingTime(0);
        
        // Start live timer
        recordingIntervalRef.current = setInterval(() => {
          setLiveRecordingTime(Math.round((Date.now() - recordingStartTimeRef.current) / 1000));
        }, 100);
        
        mediaRecorder.ondataavailable = (event) => {
          if (event.data.size > 0) {
            audioChunksRef.current.push(event.data);
          }
        };
        
        mediaRecorder.onstop = () => {
          const duration = Math.round((Date.now() - recordingStartTimeRef.current) / 1000);
          setRecordingDuration(duration);
          stream.getTracks().forEach(track => track.stop());
          
          if (duration < 1) {
            setHasRecording(false);
            setAudioDataUrl(null);
            toast({ title: "Too short!", description: "Hold the record button a bit longer and try again.", variant: "destructive" });
            return;
          }
          
          setHasRecording(true);
          const audioBlob = new Blob(audioChunksRef.current, { type: mimeType });
          const reader = new FileReader();
          reader.onloadend = () => {
            setAudioDataUrl(reader.result as string);
          };
          reader.readAsDataURL(audioBlob);
        };
        
        mediaRecorder.start();
        setIsRecording(true);
      } catch (error) {
        toast({ title: "Microphone access needed", description: "Please allow microphone access to record your answer.", variant: "destructive" });
      }
    }
  }, [isRecording, toast]);

  // Complete a video (requires voice recording)
  const completeVideo = useCallback(() => {
    if (!videoEnded || !watchingVideoId || !activeKid || !hasRecording) return;
    
    const voiceRecording: VoiceRecording = {
      recordedAt: new Date().toISOString(),
      duration: recordingDuration,
      audioData: audioDataUrl || undefined,
    };
    
    markWatchedMutation.mutate({ videoId: watchingVideoId, kidId: activeKid.id, voiceRecording });
  }, [videoEnded, watchingVideoId, activeKid, markWatchedMutation, hasRecording, recordingDuration, audioDataUrl]);
  
  // Toggle kid selection for video assignment
  const toggleKidSelection = useCallback((kidId: string) => {
    setSelectedKidIds(prev => 
      prev.includes(kidId) ? prev.filter(id => id !== kidId) : [...prev, kidId]
    );
  }, []);

  // Cycle avatar
  const cycleAvatar = useCallback(() => {
    const idx = AVATARS.indexOf(newKidAvatar);
    setNewKidAvatar(AVATARS[(idx + 1) % AVATARS.length]);
  }, [newKidAvatar]);

  // Loading state
  if (kidsLoading || videosLoading || foldersLoading) {
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-50 via-pink-50 to-yellow-50 dark:from-purple-950 dark:via-pink-950 dark:to-yellow-950">
        <div className="container mx-auto p-4 max-w-4xl">
          <div className="flex items-center justify-center gap-3 mb-8 pt-8">
            <Loader2 className="w-8 h-8 animate-spin text-purple-500" />
            <span className="text-xl font-semibold text-muted-foreground">Loading...</span>
          </div>
          <div className="space-y-4">
            <Skeleton className="h-40 w-full rounded-xl" />
            <Skeleton className="h-40 w-full rounded-xl" />
            <Skeleton className="h-60 w-full rounded-xl" />
          </div>
        </div>
      </div>
    );
  }

  // Render video player for kid mode
  if (mode === "kid" && watchingVideoId) {
    const watchingVideo = videos.find(v => v.id === watchingVideoId);
    if (!watchingVideo) return null;

    const avatarConfig = getAvatarConfig(activeKid?.avatar || "child");

    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-50 via-pink-50 to-yellow-50 dark:from-purple-950 dark:via-pink-950 dark:to-yellow-950">
        <div className="container mx-auto p-4 max-w-4xl">
          {/* Header */}
          <div className="flex items-center justify-between mb-4">
            <div className="flex items-center gap-2">
              <div className={`w-8 h-8 rounded-full bg-gradient-to-br ${avatarConfig.color} flex items-center justify-center text-white shadow-lg`}>
                <AvatarIcon avatar={activeKid?.avatar || "child"} className="w-4 h-4" />
              </div>
              <div>
                <h1 className="text-lg font-bold text-foreground">{activeKid?.name}'s Video</h1>
                <p className="text-xs text-muted-foreground">Watch until the end to complete!</p>
              </div>
            </div>
            <Button
              variant="outline"
              onClick={() => { 
                setWatchingVideoId(null); 
                setVideoEnded(false); 
                setHasRecording(false);
                setAudioDataUrl(null);
                setRecordingDuration(0);
                setTiktokStarted(false);
                setWatchProgress(0);
                setYtIsPlaying(false);
                setYtCurrentTime(0);
                setVideoDuration(0);
                if (progressIntervalRef.current) {
                  clearInterval(progressIntervalRef.current);
                  progressIntervalRef.current = null;
                }
                if (ytTimerRef.current) {
                  clearInterval(ytTimerRef.current);
                  ytTimerRef.current = null;
                }
                if (youtubePlayerRef.current) {
                  try { youtubePlayerRef.current.destroy(); } catch {}
                  youtubePlayerRef.current = null;
                }
              }}
              data-testid="button-back"
            >
              <ArrowLeft className="w-4 h-4 mr-2" />
              Back
            </Button>
          </div>

          {/* Video Player */}
          <Card className="overflow-hidden">
            <div className={`relative bg-black ${watchingVideo.platform === "tiktok" ? "h-[70vh]" : "aspect-video"}`}>
{(() => {
                // Calculate required watch percentage based on view count
                const viewCount = watchingVideo.totalViews || 0;
                const isFirstWatch = viewCount === 0;
                const requiredPercent = isFirstWatch ? 90 : 60;
                
                // Estimated video duration for TikTok (YouTube uses real duration from API)
                const estimatedDuration = 45;
                const requiredSeconds = Math.ceil((estimatedDuration * requiredPercent) / 100);
                
                // Start progress tracking for TikTok
                const startProgressTracking = () => {
                  if (progressIntervalRef.current) clearInterval(progressIntervalRef.current);
                  const startTime = Date.now();
                  tiktokStartTimeRef.current = startTime;
                  videoStartTimeRef.current = startTime;
                  
                  progressIntervalRef.current = setInterval(() => {
                    const elapsed = Math.floor((Date.now() - startTime) / 1000);
                    setElapsedSeconds(elapsed);
                    const progress = Math.min(100, Math.floor((elapsed / requiredSeconds) * 100));
                    setWatchProgress(progress);
                    
                    if (progress >= 100 && !videoEnded) {
                      setVideoEnded(true);
                      if (progressIntervalRef.current) {
                        clearInterval(progressIntervalRef.current);
                      }
                    }
                  }, 1000);
                };
                
                return watchingVideo.platform === "tiktok" ? (
                  <>
                    {!tiktokStarted ? (
                      <button
                        className="absolute inset-0 z-10 bg-gradient-to-br from-pink-500 via-red-500 to-cyan-500 flex flex-col items-center justify-center cursor-pointer"
                        onClick={() => {
                          setTiktokStarted(true);
                          startProgressTracking();
                        }}
                        data-testid="button-tiktok-start"
                      >
                        <div className="bg-white/20 backdrop-blur-sm rounded-full p-6 mb-4">
                          <Play className="w-16 h-16 text-white" />
                        </div>
                        <p className="text-white text-xl font-bold mb-2">Tap to Play with Sound</p>
                        <div className="flex items-center gap-2 text-white/80">
                          <Volume2 className="w-5 h-5" />
                          <span>Sound will be ON</span>
                        </div>
                        <p className="text-white/60 text-sm mt-2">
                          {isFirstWatch ? `Watch ${requiredPercent}% to complete` : `Re-watch: ${requiredPercent}% needed`}
                        </p>
                      </button>
                    ) : (
                        <iframe
                          width="100%"
                          height="100%"
                          src={`https://www.tiktok.com/embed/v2/${watchingVideo.ytId}?autoplay=1`}
                          title="TikTok video player"
                          frameBorder="0"
                          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; fullscreen"
                          allowFullScreen
                          style={{ pointerEvents: videoEnded ? 'none' : 'auto' }}
                        />
                    )}
                    {tiktokStarted && !videoEnded && (
                      <div className="absolute bottom-0 left-0 right-0 bg-black/70 text-white text-xs p-2 pointer-events-none">
                        <div className="flex items-center gap-2 mb-1">
                          <span>Watching: {watchProgress}%</span>
                          <span className="text-white/60">({isFirstWatch ? '90%' : '60%'} needed)</span>
                        </div>
                        <div className="w-full bg-white/30 rounded-full h-1">
                          <div 
                            className="bg-gradient-to-r from-purple-500 to-pink-500 h-1 rounded-full transition-all duration-300"
                            style={{ width: `${watchProgress}%` }}
                          />
                        </div>
                      </div>
                    )}
                    {videoEnded && hasRecording && (
                      <div 
                        className="absolute inset-0 bg-black/50 flex items-center justify-center"
                        onClick={(e) => e.stopPropagation()}
                      >
                        <div className="text-center text-white p-4">
                          <CheckCircle className="w-12 h-12 mx-auto mb-2 text-green-400" />
                          <p className="text-lg font-bold">All Done!</p>
                          <p className="text-sm opacity-80">Tap Complete Video below</p>
                        </div>
                      </div>
                    )}
                  </>
                ) : (
                  <>
                    <div ref={youtubePlayerContainerRef} className="w-full h-full" />
                    {/* Custom Controls Overlay */}
                    <div className="absolute bottom-0 left-0 right-0 z-10">
                      {/* Watch progress bar */}
                      {!videoEnded && (
                        <div className="px-3 pb-1 pointer-events-none">
                          <div className="flex items-center gap-2 mb-1 text-white text-xs">
                            <span>Watching: {watchProgress}%</span>
                            <span className="text-white/60">({isFirstWatch ? '90%' : '60%'} needed)</span>
                          </div>
                          <div className="w-full bg-white/30 rounded-full h-1">
                            <div 
                              className="bg-gradient-to-r from-purple-500 to-pink-500 h-1 rounded-full transition-all duration-300"
                              style={{ width: `${watchProgress}%` }}
                            />
                          </div>
                        </div>
                      )}
                      {/* Scrub bar */}
                      <div className="px-3 pt-1">
                        <input
                          type="range"
                          min={0}
                          max={1000}
                          value={ytIsDragging ? ytDragValue : (videoDuration > 0 ? Math.round((ytCurrentTime / videoDuration) * 1000) : 0)}
                          onInput={(e) => {
                            setYtIsDragging(true);
                            setYtDragValue(Number((e.target as HTMLInputElement).value));
                          }}
                          onChange={(e) => {
                            const val = Number(e.target.value);
                            const pct = val / 1000;
                            const seekTime = videoDuration * pct;
                            if (youtubePlayerRef.current && typeof youtubePlayerRef.current.seekTo === 'function') {
                              youtubePlayerRef.current.seekTo(seekTime, true);
                            }
                            setYtIsDragging(false);
                          }}
                          className="w-full h-1 appearance-none bg-white/30 rounded-full cursor-pointer accent-purple-500"
                          style={{ accentColor: '#a855f7' }}
                          data-testid="input-scrub-bar"
                        />
                      </div>
                      {/* Control buttons */}
                      <div className="flex items-center justify-between px-3 py-2 bg-black/70">
                        <div className="flex items-center gap-3">
                          <button
                            onClick={() => {
                              const p = youtubePlayerRef.current;
                              if (!p) return;
                              const cur = p.getCurrentTime() || 0;
                              p.seekTo(Math.max(0, cur - 10), true);
                            }}
                            className="text-white p-1"
                            data-testid="button-rewind-10s"
                          >
                            <RotateCcw className="w-5 h-5" />
                          </button>
                          <button
                            onClick={() => {
                              const p = youtubePlayerRef.current;
                              if (!p) return;
                              if (ytIsPlaying) {
                                p.pauseVideo();
                              } else {
                                p.playVideo();
                              }
                            }}
                            className="text-white bg-white/20 rounded-full p-2"
                            data-testid="button-play-pause"
                          >
                            {ytIsPlaying ? <Pause className="w-6 h-6" /> : <Play className="w-6 h-6" />}
                          </button>
                          <button
                            onClick={() => {
                              const p = youtubePlayerRef.current;
                              if (!p) return;
                              const cur = p.getCurrentTime() || 0;
                              const dur = p.getDuration() || 0;
                              p.seekTo(Math.min(dur, cur + 10), true);
                            }}
                            className="text-white p-1"
                            data-testid="button-ff-10s"
                          >
                            <SkipForward className="w-5 h-5" />
                          </button>
                        </div>
                        <div className="text-white text-xs font-mono" data-testid="text-video-time">
                          {(() => {
                            const fmt = (s: number) => {
                              s = Math.max(0, Math.floor(s));
                              const m = Math.floor(s / 60);
                              const sec = s % 60;
                              return `${m}:${String(sec).padStart(2, '0')}`;
                            };
                            return `${fmt(ytCurrentTime)} / ${fmt(videoDuration)}`;
                          })()}
                        </div>
                      </div>
                    </div>
                  </>
                );
              })()}
            </div>
            <CardContent className="p-4">
              <div className="space-y-3">
                {!videoEnded ? (
                  <div className="flex items-center gap-2 text-muted-foreground" data-testid="step-watch-video">
                    <Loader2 className="w-4 h-4 animate-spin" />
                    <p className="text-sm">Watch the video until the end...</p>
                  </div>
                ) : (
                  <>
                    <div className="flex items-center gap-2 text-green-600 dark:text-green-400" data-testid="step-video-complete">
                      <CheckCircle className="w-5 h-5" />
                      <p className="text-sm font-medium">Video watched!</p>
                    </div>
                    
                    {/* Optional recording section */}
                    {isRecording ? (
                      <div className="p-4 bg-red-50 dark:bg-red-950 rounded-lg border-2 border-red-300 dark:border-red-700" data-testid="step-voice-recording">
                        <div className="flex flex-col items-center gap-3">
                          <div className="flex items-center gap-3">
                            <div className="w-4 h-4 bg-red-500 rounded-full animate-pulse" />
                            <span className="text-3xl font-bold text-red-600 dark:text-red-400 tabular-nums" data-testid="text-recording-timer">
                              {liveRecordingTime}s
                            </span>
                          </div>
                          <p className="text-sm text-red-600 dark:text-red-400 font-medium">Recording... Tell us what you learned!</p>
                          <Button
                            size="lg"
                            variant="destructive"
                            className="w-full"
                            onClick={toggleRecording}
                            data-testid="button-stop-record"
                          >
                            <Square className="w-5 h-5 mr-2" />
                            Stop Recording
                          </Button>
                        </div>
                      </div>
                    ) : !hasRecording ? (
                      <div className="p-3 bg-purple-50 dark:bg-purple-950 rounded-lg" data-testid="step-voice-recording">
                        <div className="flex items-center gap-3">
                          <div className="flex-1">
                            <p className="text-sm font-medium">Want to record a message?</p>
                            <p className="text-xs text-muted-foreground">Tap to tell us what you learned (optional)</p>
                          </div>
                          <Button
                            size="lg"
                            variant="default"
                            onClick={toggleRecording}
                            data-testid="button-record"
                          >
                            <Mic className="w-5 h-5 mr-2" />
                            Record
                          </Button>
                        </div>
                      </div>
                    ) : (
                      <div className="flex items-center gap-2 p-3 bg-green-50 dark:bg-green-950 rounded-lg" data-testid="step-recording-saved">
                        <Mic className="w-4 h-4 text-green-600 dark:text-green-400" />
                        <p className="text-sm text-green-600 dark:text-green-400 flex-1">Recording saved ({recordingDuration}s)</p>
                        <CheckCircle className="w-4 h-4 text-green-600 dark:text-green-400" />
                        <Button
                          size="sm"
                          variant="outline"
                          onClick={() => {
                            setHasRecording(false);
                            setRecordingDuration(0);
                            setAudioDataUrl(null);
                          }}
                          data-testid="button-re-record"
                        >
                          <RotateCcw className="w-3 h-3 mr-1" />
                          Redo
                        </Button>
                      </div>
                    )}

                    {/* Complete button - always enabled after video ends */}
                    <Button
                      variant="default"
                      className="w-full bg-gradient-to-r from-purple-500 to-pink-500"
                      disabled={markWatchedMutation.isPending}
                      onClick={completeVideo}
                      data-testid="button-complete"
                    >
                      {markWatchedMutation.isPending ? (
                        <>
                          <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                          Saving...
                        </>
                      ) : (
                        <>
                          <Star className="w-4 h-4 mr-2" />
                          Complete Video!
                        </>
                      )}
                    </Button>
                  </>
                )}
              </div>
            </CardContent>
          </Card>
        </div>
      </div>
    );
  }

  // Kid mode - playlist view
  if (mode === "kid") {
    const stats = getKidStats(activeKid?.id || "");
    const avatarConfig = getAvatarConfig(activeKid?.avatar || "child");
    
    return (
      <div className="min-h-screen bg-gradient-to-br from-purple-50 via-pink-50 to-yellow-50 dark:from-purple-950 dark:via-pink-950 dark:to-yellow-950">
        <div className="container mx-auto p-4 max-w-4xl">
          {/* Header */}
          <div className="flex flex-col sm:flex-row items-start sm:items-center justify-between gap-4 mb-6">
            <div className="flex items-center gap-2">
              <div className={`w-10 h-10 rounded-full bg-gradient-to-br ${avatarConfig.color} flex items-center justify-center text-white shadow-lg`}>
                <AvatarIcon avatar={activeKid?.avatar || "child"} className="w-5 h-5" />
              </div>
              <div>
                <h1 className="text-xl font-bold bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">
                  {activeKid?.name}'s Videos
                </h1>
                <div className="flex items-center gap-2 mt-1">
                  <Badge variant="secondary" className="bg-green-100 text-green-700 dark:bg-green-900 dark:text-green-300">
                    <CheckCircle className="w-3 h-3 mr-1" />
                    {stats.watched} watched
                  </Badge>
                  <Badge variant="secondary" className="bg-yellow-100 text-yellow-700 dark:bg-yellow-900 dark:text-yellow-300">
                    <Play className="w-3 h-3 mr-1" />
                    {stats.pending} pending
                  </Badge>
                </div>
              </div>
            </div>
            <div className="flex items-center gap-2">
              {/* Add to Home Screen button - show if not already installed as PWA */}
              {!isStandalone && (
                <Button
                  variant="outline"
                  size="sm"
                  onClick={handleInstallClick}
                  data-testid="button-add-home-screen"
                >
                  <Download className="w-4 h-4 mr-1" />
                  Add to Home
                </Button>
              )}
              {isLockedKidMode ? (
                <Button
                  variant="ghost"
                  size="sm"
                  onClick={() => {
                    localStorage.removeItem('lockedKidId');
                    window.location.href = '/';
                  }}
                  data-testid="button-exit-kid-mode"
                >
                  <LogOut className="w-4 h-4 mr-1" />
                  Exit
                </Button>
              ) : (
                <Button
                  variant="outline"
                  onClick={() => setMode("parent")}
                  data-testid="button-parent-mode"
                >
                  <User className="w-4 h-4 mr-2" />
                  Parent Mode
                </Button>
              )}
            </div>
          </div>

          {/* Kid Selector - only show if not locked to specific kid */}
          {!isLockedKidMode && (
          <Card className="mb-4">
            <CardContent className="p-3">
              <p className="text-xs font-medium text-muted-foreground mb-2">Who's watching?</p>
              <div className="flex flex-wrap gap-1">
                {kids.map(k => {
                  const config = getAvatarConfig(k.avatar);
                  return (
                    <Button
                      key={k.id}
                      size="sm"
                      variant={activeKidId === k.id ? "default" : "outline"}
                      onClick={() => setActiveKidId(k.id)}
                      className={activeKidId === k.id ? `bg-gradient-to-r ${config.color}` : ""}
                      data-testid={`button-kid-${k.id}`}
                    >
                      <AvatarIcon avatar={k.avatar} className="w-4 h-4 mr-1" />
                      {k.name}
                    </Button>
                  );
                })}
              </div>
            </CardContent>
          </Card>
          )}

          {/* Video List - Organized by Folders */}
          <div className="space-y-4">
            {assignedVideos.length === 0 ? (
              <Card className="p-6 text-center">
                <div className="w-14 h-14 mx-auto mb-3 rounded-full bg-purple-100 dark:bg-purple-900 flex items-center justify-center">
                  <Video className="w-7 h-7 text-purple-500" />
                </div>
                <h3 className="text-base font-semibold mb-1">No videos yet!</h3>
                <p className="text-sm text-muted-foreground">
                  Ask a parent to add some fun videos for you!
                </p>
              </Card>
            ) : (
              kidVideosByFolder.map(group => (
                <Card key={group.id} className="overflow-hidden" data-testid={`kid-folder-${group.id}`}>
                  {/* Folder Header */}
                  <button
                    onClick={() => {
                      const newExpanded = new Set(expandedFolders);
                      if (newExpanded.has(group.id)) {
                        newExpanded.delete(group.id);
                      } else {
                        newExpanded.add(group.id);
                      }
                      setExpandedFolders(newExpanded);
                    }}
                    className="w-full flex items-center gap-3 p-3 bg-gradient-to-r from-purple-100 to-pink-100 dark:from-purple-900/50 dark:to-pink-900/50 text-left"
                    data-testid={`button-kid-folder-${group.id}`}
                  >
                    {expandedFolders.has(group.id) ? (
                      <ChevronDown className="w-5 h-5 text-purple-500" />
                    ) : (
                      <ChevronRight className="w-5 h-5 text-purple-500" />
                    )}
                    <FolderIcon className="w-5 h-5 text-purple-500" />
                    <span className="font-semibold text-purple-700 dark:text-purple-300">{group.name}</span>
                    <Badge variant="secondary" className="ml-auto bg-purple-200 dark:bg-purple-800">
                      {group.videos.length} video{group.videos.length !== 1 ? 's' : ''}
                    </Badge>
                  </button>
                  
                  {/* Videos in Folder */}
                  {expandedFolders.has(group.id) && (
                    <div className="divide-y">
                      {group.videos.map(video => {
                        const isWatched = video.progress?.[activeKid?.id]?.watched;
                        const viewCount = video.totalViews || 0;
                        const isMaxed = viewCount >= MAX_VIDEO_VIEWS;
                        const isLocked = !isWatched && isVideoLocked(video, group.videos, activeKid?.id || "");
                        const canWatch = !isMaxed && !isLocked;
                        const canRewatch = isWatched && !isMaxed;
                        const priority = video.priority || 5;
                        
                        return (
                          <div 
                            key={video.id} 
                            className={`flex flex-row items-stretch gap-2 ${isWatched ? 'opacity-75' : isMaxed || isLocked ? 'opacity-60' : ''}`}
                          >
                            {/* Thumbnail - full row height */}
                            <div className="relative w-20 min-h-[4rem] bg-gradient-to-br from-purple-200 to-pink-200 dark:from-purple-800 dark:to-pink-800 flex items-center justify-center shrink-0">
                              {video.platform === "tiktok" ? (
                                <TikTokThumbnail videoId={video.ytId} className="w-full h-full" />
                              ) : (
                                <img
                                  src={`https://img.youtube.com/vi/${video.ytId}/mqdefault.jpg`}
                                  alt="Video thumbnail"
                                  className="w-full h-full object-cover"
                                  onError={(e) => {
                                    e.currentTarget.style.display = 'none';
                                  }}
                                />
                              )}
                              {isWatched && (
                                <div className="absolute inset-0 bg-green-500/80 flex items-center justify-center">
                                  <CheckCircle className="w-5 h-5 text-white" />
                                </div>
                              )}
                              {!isWatched && isMaxed && (
                                <div className="absolute inset-0 bg-red-500/80 flex items-center justify-center">
                                  <AlertTriangle className="w-5 h-5 text-white" />
                                </div>
                              )}
                              {!isWatched && !isMaxed && isLocked && (
                                <div className="absolute inset-0 bg-gray-500/80 flex items-center justify-center">
                                  <Lock className="w-5 h-5 text-white" />
                                </div>
                              )}
                            </div>
                            {/* Content - compact */}
                            <div className="flex-1 min-w-0 py-2">
                              <div className="flex items-center gap-1 mb-1 flex-wrap">
                                {video.platform === "tiktok" ? (
                                  <SiTiktok className="w-3 h-3 shrink-0" />
                                ) : (
                                  <Youtube className="w-3 h-3 text-red-500 shrink-0" />
                                )}
                                <span className="text-xs text-muted-foreground font-mono truncate max-w-[100px]">{video.ytId}</span>
                                <Badge variant="outline" className="text-xs" data-testid={`badge-priority-${video.id}`}>
                                  Lv.{priority}
                                </Badge>
                              </div>
                              <div className="flex flex-wrap items-center gap-1">
                                {isWatched ? (
                                  <Badge className="bg-green-500 text-white text-xs" data-testid={`badge-status-${video.id}`}>
                                    <CheckCircle className="w-3 h-3 mr-0.5" />
                                    Done
                                  </Badge>
                                ) : isLocked ? (
                                  <Badge variant="secondary" className="text-xs bg-gray-200 dark:bg-gray-700" data-testid={`badge-status-${video.id}`}>
                                    <Lock className="w-3 h-3 mr-0.5" />
                                    Locked
                                  </Badge>
                                ) : isMaxed ? (
                                  <Badge variant="destructive" className="text-xs" data-testid={`badge-status-${video.id}`}>
                                    <AlertTriangle className="w-3 h-3 mr-0.5" />
                                    Max
                                  </Badge>
                                ) : (
                                  <Badge variant="secondary" className="text-xs" data-testid={`badge-status-${video.id}`}>
                                    <Sparkles className="w-3 h-3 mr-0.5" />
                                    Ready
                                  </Badge>
                                )}
                                <Badge variant="outline" className="text-xs" data-testid={`badge-views-kid-${video.id}`}>
                                  <Eye className="w-2 h-2 mr-0.5" />
                                  {viewCount}/{MAX_VIDEO_VIEWS}
                                </Badge>
                              </div>
                            </div>
                            {/* Watch button */}
                            <div className="flex items-center pr-2">
                              {canWatch && (
                                <Button
                                  size="sm"
                                  onClick={() => startWatch(video.id)}
                                  className={`shrink-0 ${canRewatch ? "bg-gradient-to-r from-green-500 to-teal-500" : "bg-gradient-to-r from-purple-500 to-pink-500"}`}
                                  data-testid={`button-watch-${video.id}`}
                                >
                                  <Play className="w-4 h-4 mr-1" />
                                  {canRewatch ? "Again" : "Watch"}
                                </Button>
                              )}
                            </div>
                          </div>
                        );
                      })}
                    </div>
                  )}
                </Card>
              ))
            )}
          </div>
          
          {/* Add to Home Screen Instructions Dialog */}
          <Dialog open={showHomeScreenInstructions} onOpenChange={setShowHomeScreenInstructions}>
            <DialogContent className="max-w-sm">
              <DialogHeader>
                <DialogTitle className="flex items-center gap-2">
                  <Download className="w-5 h-5" />
                  Add to Home Screen
                </DialogTitle>
              </DialogHeader>
              <div className="space-y-4">
                {isIOS ? (
                  <>
                    <p className="text-sm text-muted-foreground">
                      To add {activeKid?.name}'s video app to your home screen:
                    </p>
                    <ol className="text-sm space-y-3">
                      <li className="flex items-start gap-2">
                        <span className="bg-primary text-primary-foreground rounded-full w-5 h-5 flex items-center justify-center text-xs shrink-0">1</span>
                        <span>Tap the <strong>Share button</strong> at the bottom of Safari (square with arrow pointing up)</span>
                      </li>
                      <li className="flex items-start gap-2">
                        <span className="bg-primary text-primary-foreground rounded-full w-5 h-5 flex items-center justify-center text-xs shrink-0">2</span>
                        <span>Scroll down and tap <strong>"Add to Home Screen"</strong></span>
                      </li>
                      <li className="flex items-start gap-2">
                        <span className="bg-primary text-primary-foreground rounded-full w-5 h-5 flex items-center justify-center text-xs shrink-0">3</span>
                        <span>Tap <strong>"Add"</strong> in the top right corner</span>
                      </li>
                    </ol>
                    <p className="text-xs text-muted-foreground bg-muted p-2 rounded">
                      The app will open directly to {activeKid?.name}'s videos every time!
                    </p>
                  </>
                ) : isAndroid ? (
                  <>
                    <p className="text-sm text-muted-foreground">
                      To add {activeKid?.name}'s video app to your home screen:
                    </p>
                    <ol className="text-sm space-y-3">
                      <li className="flex items-start gap-2">
                        <span className="bg-primary text-primary-foreground rounded-full w-5 h-5 flex items-center justify-center text-xs shrink-0">1</span>
                        <span>Tap the <strong>menu button</strong> (three dots) in Chrome</span>
                      </li>
                      <li className="flex items-start gap-2">
                        <span className="bg-primary text-primary-foreground rounded-full w-5 h-5 flex items-center justify-center text-xs shrink-0">2</span>
                        <span>Tap <strong>"Add to Home screen"</strong> or <strong>"Install app"</strong></span>
                      </li>
                      <li className="flex items-start gap-2">
                        <span className="bg-primary text-primary-foreground rounded-full w-5 h-5 flex items-center justify-center text-xs shrink-0">3</span>
                        <span>Tap <strong>"Add"</strong> to confirm</span>
                      </li>
                    </ol>
                  </>
                ) : (
                  <p className="text-sm text-muted-foreground">
                    Use your browser's menu to add this page to your home screen or bookmarks.
                  </p>
                )}
              </div>
              <a 
                href="/api/download-icon"
                download="kid-video-app-icon.png"
                className="block"
              >
                <Button 
                  variant="outline"
                  className="w-full mt-2"
                  data-testid="button-download-icon"
                >
                  <Download className="w-4 h-4 mr-2" />
                  Download App Icon
                </Button>
              </a>
              <Button 
                onClick={() => setShowHomeScreenInstructions(false)} 
                className="w-full mt-2"
                data-testid="button-close-home-instructions"
              >
                Got it!
              </Button>
            </DialogContent>
          </Dialog>
        </div>
      </div>
    );
  }

  // Parent mode
  return (
    <div className="min-h-screen bg-gradient-to-br from-purple-50 via-blue-50 to-cyan-50 dark:from-purple-950 dark:via-blue-950 dark:to-cyan-950">
      <div className="container mx-auto p-4 max-w-4xl">
        {/* Header */}
        <div className="flex items-center justify-between gap-2 mb-4">
          <div>
            <h1 className="text-lg font-bold bg-gradient-to-r from-purple-600 to-blue-600 bg-clip-text text-transparent flex items-center gap-2">
              <Sparkles className="w-4 h-4 text-purple-500" />
              Kid Video App
            </h1>
          </div>
          <div className="flex items-center gap-2">
            {/* Feedback Button */}
            <Dialog open={feedbackOpen} onOpenChange={(open) => { setFeedbackOpen(open); if (!open) resetFeedbackForm(); }}>
              <DialogTrigger asChild>
                <Button variant="outline" size="icon" data-testid="button-feedback">
                  <MessageSquare className="w-4 h-4" />
                </Button>
              </DialogTrigger>
              <DialogContent>
                <DialogHeader>
                  <DialogTitle className="flex items-center gap-2">
                    <MessageSquare className="w-4 h-4" />
                    Send Feedback
                  </DialogTitle>
                </DialogHeader>
                <div className="space-y-4">
                  {/* Feedback Type Selector */}
                  <div className="flex gap-2 flex-wrap">
                    <Button
                      variant={feedbackType === 'text' ? 'default' : 'outline'}
                      size="sm"
                      onClick={() => setFeedbackType('text')}
                      data-testid="button-feedback-type-text"
                    >
                      <Pencil className="w-3 h-3 mr-1" />
                      Text
                    </Button>
                    <Button
                      variant={feedbackType === 'voice' ? 'default' : 'outline'}
                      size="sm"
                      onClick={() => setFeedbackType('voice')}
                      data-testid="button-feedback-type-voice"
                    >
                      <Mic className="w-3 h-3 mr-1" />
                      Voice
                    </Button>
                    <Button
                      variant={feedbackType === 'video' ? 'default' : 'outline'}
                      size="sm"
                      onClick={() => setFeedbackType('video')}
                      data-testid="button-feedback-type-video"
                    >
                      <Video className="w-3 h-3 mr-1" />
                      Video Link
                    </Button>
                    <Button
                      variant={feedbackType === 'screenshot' ? 'default' : 'outline'}
                      size="sm"
                      onClick={() => setFeedbackType('screenshot')}
                      data-testid="button-feedback-type-screenshot"
                    >
                      <Image className="w-3 h-3 mr-1" />
                      Screenshot
                    </Button>
                  </div>

                  {/* Feedback Input Based on Type */}
                  {feedbackType === 'text' && (
                    <Textarea
                      placeholder="Tell us what you think, report bugs, or share ideas..."
                      value={feedbackText}
                      onChange={(e) => setFeedbackText(e.target.value)}
                      className="min-h-[100px]"
                      data-testid="input-feedback-text"
                    />
                  )}

                  {feedbackType === 'voice' && (
                    <div className="flex flex-col items-center gap-4 py-4">
                      {feedbackAudioData ? (
                        <div className="flex items-center gap-2">
                          <Button
                            variant="outline"
                            size="sm"
                            onClick={() => {
                              const audio = new Audio(feedbackAudioData);
                              audio.play();
                            }}
                            data-testid="button-play-feedback-audio"
                          >
                            <Volume2 className="w-4 h-4 mr-1" />
                            Play ({feedbackAudioDuration}s)
                          </Button>
                          <Button
                            variant="ghost"
                            size="sm"
                            onClick={() => { setFeedbackAudioData(null); setFeedbackAudioDuration(0); }}
                          >
                            <RotateCcw className="w-4 h-4" />
                          </Button>
                        </div>
                      ) : (
                        <Button
                          size="lg"
                          variant={feedbackRecording ? "destructive" : "default"}
                          className="rounded-full w-16 h-16"
                          onMouseDown={startFeedbackRecording}
                          onMouseUp={stopFeedbackRecording}
                          onTouchStart={startFeedbackRecording}
                          onTouchEnd={stopFeedbackRecording}
                          data-testid="button-feedback-record"
                        >
                          {feedbackRecording ? (
                            <div className="flex flex-col items-center">
                              <Square className="w-5 h-5" />
                              <span className="text-xs">{feedbackLiveTime}s</span>
                            </div>
                          ) : (
                            <Mic className="w-6 h-6" />
                          )}
                        </Button>
                      )}
                      <p className="text-xs text-muted-foreground text-center">
                        {feedbackRecording ? "Recording... Release to stop" : feedbackAudioData ? "Recording saved" : "Hold to record"}
                      </p>
                    </div>
                  )}

                  {feedbackType === 'video' && (
                    <Input
                      placeholder="Paste YouTube or TikTok video link..."
                      value={feedbackVideoUrl}
                      onChange={(e) => setFeedbackVideoUrl(e.target.value)}
                      data-testid="input-feedback-video"
                    />
                  )}

                  {feedbackType === 'screenshot' && (
                    <div className="space-y-2">
                      <input
                        type="file"
                        accept="image/*"
                        onChange={handleScreenshotUpload}
                        className="hidden"
                        id="screenshot-upload"
                        data-testid="input-feedback-screenshot"
                      />
                      <label
                        htmlFor="screenshot-upload"
                        className="flex flex-col items-center gap-2 p-6 border-2 border-dashed rounded-lg cursor-pointer hover:border-primary/50 transition-colors"
                      >
                        {feedbackScreenshot ? (
                          <img src={feedbackScreenshot} alt="Screenshot" className="max-h-40 rounded" />
                        ) : (
                          <>
                            <Camera className="w-8 h-8 text-muted-foreground" />
                            <span className="text-sm text-muted-foreground">Click to upload screenshot</span>
                          </>
                        )}
                      </label>
                    </div>
                  )}

                  {/* Submit Button */}
                  <Button
                    className="w-full"
                    onClick={submitFeedback}
                    disabled={feedbackMutation.isPending}
                    data-testid="button-submit-feedback"
                  >
                    {feedbackMutation.isPending ? (
                      <Loader2 className="w-4 h-4 mr-2 animate-spin" />
                    ) : (
                      <Send className="w-4 h-4 mr-2" />
                    )}
                    Send Feedback
                  </Button>
                </div>
              </DialogContent>
            </Dialog>

            {/* Settings Button */}
            <Dialog open={settingsOpen} onOpenChange={setSettingsOpen}>
              <DialogTrigger asChild>
                <Button variant="outline" size="icon" data-testid="button-settings">
                  <Settings className="w-4 h-4" />
                </Button>
              </DialogTrigger>
              <DialogContent>
                <DialogHeader>
                  <DialogTitle className="flex items-center gap-2">
                    <User className="w-4 h-4" />
                    Manage Kids ({kids.length}/6)
                  </DialogTitle>
                </DialogHeader>
                <div className="space-y-4">
                  {/* Add Kid Form */}
                  <div className="flex gap-2">
                    <Input
                      placeholder="Kid's name"
                      value={newKidName}
                      onChange={e => setNewKidName(e.target.value)}
                      className="flex-1 text-sm"
                      data-testid="input-kid-name"
                    />
                    <Button
                      variant="outline"
                      size="icon"
                      onClick={cycleAvatar}
                      className={`bg-gradient-to-br ${getAvatarConfig(newKidAvatar).color} text-white border-0`}
                      data-testid="button-cycle-avatar"
                    >
                      <AvatarIcon avatar={newKidAvatar} className="w-4 h-4" />
                    </Button>
                    <Button 
                      size="sm"
                      onClick={addKid} 
                      disabled={createKidMutation.isPending || kids.length >= 6}
                      data-testid="button-add-kid"
                    >
                      {createKidMutation.isPending ? (
                        <Loader2 className="w-3 h-3 mr-1 animate-spin" />
                      ) : (
                        <Plus className="w-3 h-3 mr-1" />
                      )}
                      Add
                    </Button>
                  </div>
                  
                  {/* Kids List */}
                  {kids.length === 0 ? (
                    <p className="text-sm text-muted-foreground text-center py-2">No kids added yet.</p>
                  ) : (
                    <div className="space-y-2">
                      {kids.map(kid => {
                        const stats = getKidStats(kid.id);
                        const avatarConfig = getAvatarConfig(kid.avatar);
                        const isEditing = editingKidId === kid.id;
                        return (
                          <div
                            key={kid.id}
                            className="flex items-center gap-2 p-2 rounded-lg bg-muted/50"
                          >
                            <div className={`w-8 h-8 rounded-full bg-gradient-to-br ${avatarConfig.color} flex items-center justify-center text-white shrink-0`}>
                              <AvatarIcon avatar={kid.avatar} className="w-4 h-4" />
                            </div>
                            <div className="flex-1 min-w-0">
                              {isEditing ? (
                                <div className="flex items-center gap-1">
                                  <Input
                                    value={editingKidName}
                                    onChange={e => setEditingKidName(e.target.value)}
                                    className="h-7 text-sm"
                                    data-testid={`input-edit-kid-${kid.id}`}
                                    autoFocus
                                  />
                                  <Button
                                    size="icon"
                                    variant="ghost"
                                    className="h-7 w-7"
                                    onClick={() => {
                                      if (editingKidName.trim()) {
                                        updateKidMutation.mutate({ id: kid.id, name: editingKidName.trim() });
                                      }
                                    }}
                                    disabled={updateKidMutation.isPending}
                                    data-testid={`button-save-kid-${kid.id}`}
                                  >
                                    <Check className="w-3 h-3" />
                                  </Button>
                                  <Button
                                    size="icon"
                                    variant="ghost"
                                    className="h-7 w-7"
                                    onClick={() => { setEditingKidId(null); setEditingKidName(""); }}
                                    data-testid={`button-cancel-edit-${kid.id}`}
                                  >
                                    <X className="w-3 h-3" />
                                  </Button>
                                </div>
                              ) : (
                                <>
                                  <p className="text-sm font-semibold truncate">{kid.name}</p>
                                  <div className="flex items-center gap-1">
                                    <Badge variant="outline" className="text-xs">
                                      <CheckCircle className="w-2 h-2 mr-1 text-green-500" />
                                      {stats.watched} watched
                                    </Badge>
                                    <Badge variant="outline" className="text-xs">
                                      <Play className="w-2 h-2 mr-1 text-yellow-500" />
                                      {stats.pending} pending
                                    </Badge>
                                  </div>
                                </>
                              )}
                            </div>
                            {!isEditing && (
                              <div className="flex items-center gap-1 shrink-0">
                                <Button
                                  size="icon"
                                  variant="ghost"
                                  className="h-7 w-7"
                                  onClick={() => {
                                    const link = `${window.location.origin}/kid/${kid.id}`;
                                    navigator.clipboard.writeText(link);
                                    toast({ 
                                      title: `Link copied for ${kid.name}!`, 
                                      description: "Open this link in Safari/Chrome, tap Share, then 'Add to Home Screen' to create an app icon." 
                                    });
                                  }}
                                  data-testid={`button-copy-link-${kid.id}`}
                                  title="Copy link for home screen shortcut"
                                >
                                  <Download className="w-3 h-3" />
                                </Button>
                                <Button
                                  size="icon"
                                  variant="ghost"
                                  className="h-7 w-7"
                                  onClick={() => { setEditingKidId(kid.id); setEditingKidName(kid.name); }}
                                  data-testid={`button-edit-kid-${kid.id}`}
                                >
                                  <Pencil className="w-3 h-3" />
                                </Button>
                                <Button
                                  size="icon"
                                  variant="ghost"
                                  className="h-7 w-7 text-destructive"
                                  onClick={() => deleteKidMutation.mutate(kid.id)}
                                  disabled={deleteKidMutation.isPending}
                                  data-testid={`button-delete-kid-${kid.id}`}
                                >
                                  <Trash2 className="w-3 h-3" />
                                </Button>
                              </div>
                            )}
                          </div>
                        );
                      })}
                    </div>
                  )}
                  
                  {/* Add to Home Screen instructions */}
                  {kids.length > 0 && (
                    <div className="p-3 rounded-lg bg-purple-50 dark:bg-purple-950 border border-purple-200 dark:border-purple-800">
                      <div className="flex items-center gap-2 mb-2">
                        <Download className="w-4 h-4 text-purple-600" />
                        <p className="text-sm font-semibold text-purple-800 dark:text-purple-200">Add Kid Shortcuts to Home Screen</p>
                      </div>
                      <p className="text-xs text-purple-700 dark:text-purple-300">
                        Tap the <Download className="w-3 h-3 inline" /> button next to a kid's name to copy their personal link. 
                        Then open the link in Safari (iPhone) or Chrome (Android), tap Share, and select "Add to Home Screen". 
                        The shortcut will open directly to that kid's videos!
                      </p>
                    </div>
                  )}

                  {/* Account ID */}
                  {user?.id && (
                    <p className="text-xs text-muted-foreground text-center pt-2 border-t" data-testid="text-account-id">
                      Account ID: {user.id}
                    </p>
                  )}
                </div>
              </DialogContent>
            </Dialog>

            {/* Logout Button */}
            <Button
              variant="outline"
              size="icon"
              asChild
              data-testid="button-logout"
            >
              <a href="/api/logout">
                <LogOut className="w-4 h-4" />
              </a>
            </Button>

            <Button
              size="sm"
              onClick={() => setMode("kid")}
              className="bg-gradient-to-r from-purple-500 to-pink-500"
              data-testid="button-kid-mode"
            >
              <Play className="w-4 h-4 mr-1" />
              Kid Mode
            </Button>
          </div>
        </div>
        
        {/* Kids row with stats + add kid inline */}
        <div className="flex flex-wrap items-center gap-2 mb-4">
          {kids.map(kid => {
            const stats = getKidStats(kid.id);
            const avatarConfig = getAvatarConfig(kid.avatar);
            return (
              <Badge 
                key={kid.id} 
                variant="secondary" 
                className="text-xs py-1 cursor-pointer" 
                onClick={() => setActivityStatsKidId(kid.id)}
                data-testid={`badge-kid-stats-${kid.id}`}
              >
                <div className={`w-4 h-4 rounded-full bg-gradient-to-br ${avatarConfig.color} flex items-center justify-center text-white mr-1`}>
                  <AvatarIcon avatar={kid.avatar} className="w-2 h-2" />
                </div>
                {kid.name}: {stats.watched}/{stats.total}
              </Badge>
            );
          })}
          {kids.length < 6 && (
            <div className="flex items-center gap-1">
              <Input
                placeholder="Kid name"
                value={newKidName}
                onChange={e => setNewKidName(e.target.value)}
                className="h-8 w-24 text-xs"
                data-testid="input-kid-name-inline"
              />
              <Button
                size="sm"
                variant="secondary"
                className="h-8"
                onClick={addKid}
                disabled={createKidMutation.isPending || kids.length >= 6}
                data-testid="button-add-kid-inline"
              >
                {createKidMutation.isPending ? (
                  <Loader2 className="w-3 h-3 mr-1 animate-spin" />
                ) : (
                  <Plus className="w-3 h-3 mr-1" />
                )}
                Kid
              </Button>
            </div>
          )}
        </div>

        {/* Global Playlists Section with inline trial badge */}
        {globalPlaylists.length > 0 && (
          <Card className="mb-4">
            <CardHeader className="pb-2 pt-3 px-3">
              <CardTitle className="text-sm flex items-center justify-between gap-2">
                <div className="flex items-center gap-2 min-w-0">
                  <Globe className="w-4 h-4 text-blue-500 shrink-0" />
                  <span className="truncate">Curated Playlists</span>
                </div>
                <div className="flex items-center gap-1 shrink-0">
                  {trialStatus?.show && (
                    <Badge variant="secondary" className="text-xs gap-1" data-testid="badge-trial-status">
                      <Gift className="w-3 h-3 text-amber-500" />
                      {trialStatus.frozen
                        ? "FREE"
                        : `FREE \u2022 ${trialStatus.daysLeft} days left`}
                    </Badge>
                  )}
                  <Button
                    variant="ghost"
                    size="sm"
                    onClick={() => setShowGlobalPlaylists(!showGlobalPlaylists)}
                    data-testid="button-toggle-global-playlists"
                  >
                    {showGlobalPlaylists ? <ChevronDown className="w-4 h-4" /> : <ChevronRight className="w-4 h-4" />}
                  </Button>
                </div>
              </CardTitle>
              <p className="text-xs text-muted-foreground mt-1" data-testid="text-trial-subtext">
                Personal playlists are always free.
              </p>
            </CardHeader>
            {showGlobalPlaylists && (
              <CardContent className="pt-0 px-3 pb-3">
                <div className="space-y-2">
                  {globalPlaylists.map(gp => {
                    const isSubscribed = globalSubscriptions.some(s => s.masterFolderId === gp.id);
                    return (
                      <div key={gp.id} className="flex items-center justify-between gap-2 p-2 border rounded-md" data-testid={`global-playlist-${gp.id}`}>
                        <div className="flex items-center gap-2 min-w-0">
                          <FolderIcon className="w-4 h-4 text-blue-500 shrink-0" />
                          <span className="text-sm font-medium truncate">{gp.name}</span>
                          <Badge variant="secondary" className="text-xs shrink-0">{gp.videoCount} videos</Badge>
                        </div>
                        {isMaster ? (
                          <Badge variant="outline" className="text-xs shrink-0" data-testid={`badge-your-playlist-${gp.id}`}>
                            Yours
                          </Badge>
                        ) : (
                          <Button
                            size="sm"
                            variant={isSubscribed ? "outline" : "secondary"}
                            onClick={() => {
                              if (isSubscribed) {
                                unsubscribeMutation.mutate({ masterFolderId: gp.id });
                              } else {
                                subscribeMutation.mutate({ masterFolderId: gp.id, kidIds: [] });
                              }
                            }}
                            disabled={subscribeMutation.isPending || unsubscribeMutation.isPending}
                            data-testid={`button-subscribe-${gp.id}`}
                          >
                            {isSubscribed ? "Remove" : "Add"}
                          </Button>
                        )}
                      </div>
                    );
                  })}
                </div>
              </CardContent>
            )}
          </Card>
        )}

        {/* Add Video Card - compact merged layout */}
        <Card className="mb-4">
          <CardHeader className="pb-1 pt-3 px-3">
            <CardTitle className="flex items-center justify-between gap-2 text-sm">
              <div className="flex items-center gap-2">
                <Video className="w-4 h-4 text-purple-500" />
                Add Video
              </div>
              <Button
                size="sm"
                variant="secondary"
                onClick={() => setIsFolderEditMode(!isFolderEditMode)}
                data-testid="button-toggle-folder-edit"
              >
                <FolderPlus className="w-3 h-3 mr-1" />
                Playlist
              </Button>
            </CardTitle>
          </CardHeader>
          <CardContent className="pt-0 px-3 pb-3 space-y-2">
            {/* Folder selection */}
            <div className="flex flex-wrap gap-1">
              <Button
                variant={selectedFolderId === "unfiled" ? "default" : "outline"}
                size="sm"
                onClick={() => setSelectedFolderId(selectedFolderId === "unfiled" ? null : "unfiled")}
                data-testid="button-folder-none"
              >
                <FolderIcon className="w-3 h-3 mr-1" />
                Unfiled
              </Button>
              {folders.filter(f => !f.name.startsWith("__global_")).map(folder => (
                <div key={folder.id} className="flex items-center gap-0.5">
                  {editingFolderId === folder.id ? (
                    <div className="flex items-center gap-1">
                      <Input
                        value={editingFolderName}
                        onChange={e => setEditingFolderName(e.target.value)}
                        className="h-8 w-32 text-sm"
                        autoFocus
                        onKeyDown={e => {
                          if (e.key === "Enter") saveEditingFolder();
                          if (e.key === "Escape") cancelEditingFolder();
                        }}
                        data-testid={`input-edit-folder-${folder.id}`}
                      />
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={saveEditingFolder}
                        disabled={updateFolderMutation.isPending}
                        data-testid={`button-save-folder-${folder.id}`}
                      >
                        <Check className="w-3 h-3 text-green-600" />
                      </Button>
                      <Button
                        variant="ghost"
                        size="icon"
                        onClick={cancelEditingFolder}
                        data-testid={`button-cancel-edit-folder-${folder.id}`}
                      >
                        <X className="w-3 h-3" />
                      </Button>
                    </div>
                  ) : (
                    <>
                      <Button
                        variant={selectedFolderId === folder.id ? "default" : "outline"}
                        size="sm"
                        onClick={() => setSelectedFolderId(selectedFolderId === folder.id ? null : folder.id)}
                        data-testid={`button-folder-${folder.id}`}
                      >
                        {isMaster ? (
                          <Globe className="w-3 h-3 mr-1 text-blue-500" />
                        ) : (
                          <FolderIcon className="w-3 h-3 mr-1" />
                        )}
                        {folder.name}
                      </Button>
                      {isFolderEditMode && (
                        <>
                          <Button
                            variant="ghost"
                            size="icon"
                            className="h-6 w-6"
                            onClick={() => startEditingFolder(folder)}
                            data-testid={`button-edit-folder-${folder.id}`}
                          >
                            <Pencil className="w-3 h-3" />
                          </Button>
                          <Button
                            variant="ghost"
                            size="icon"
                            className="h-6 w-6"
                            onClick={() => setDeletingFolderId(folder.id)}
                            disabled={deleteFolderMutation.isPending}
                            data-testid={`button-delete-folder-${folder.id}`}
                          >
                            <Trash2 className="w-3 h-3 text-destructive" />
                          </Button>
                        </>
                      )}
                    </>
                  )}
                </div>
              ))}
              {isFolderEditMode && (
                <div className="flex gap-1 items-center">
                  <Input
                    placeholder="New playlist"
                    value={newFolderName}
                    onChange={e => setNewFolderName(e.target.value)}
                    className="h-8 w-28 text-xs"
                    data-testid="input-folder-name"
                  />
                  <Button 
                    size="sm"
                    className="h-8"
                    onClick={addFolder} 
                    disabled={createFolderMutation.isPending}
                    data-testid="button-add-folder"
                  >
                    {createFolderMutation.isPending ? (
                      <Loader2 className="w-3 h-3" />
                    ) : (
                      <FolderPlus className="w-3 h-3" />
                    )}
                  </Button>
                </div>
              )}
            </div>

            {/* URL input */}
            <div className="flex gap-1">
              <Input
                placeholder="Paste YouTube or TikTok link"
                value={videoUrl}
                onChange={e => setVideoUrl(e.target.value)}
                className="flex-1 text-sm"
                data-testid="input-video-url"
              />
              <Button 
                size="icon"
                variant="outline"
                onClick={pasteFromClipboard}
                title="Paste from clipboard"
                data-testid="button-paste-url"
              >
                <Clipboard className="w-4 h-4" />
              </Button>
            </div>
            
            {/* Priority Selection */}
            <div className="flex items-center gap-1">
              <span className="text-xs font-medium whitespace-nowrap">Lv:</span>
              <div className="flex flex-1 gap-1">
                {[1, 2, 3, 4, 5, 6, 7, 8, 9].map(level => (
                  <Button
                    key={level}
                    variant={videoPriority === level ? "default" : "outline"}
                    size="sm"
                    className={`flex-1 h-8 p-0 text-xs ${videoPriority === level ? 'bg-purple-500' : ''}`}
                    onClick={() => setVideoPriority(videoPriority === level ? null : level)}
                    data-testid={`priority-${level}`}
                  >
                    {level}
                  </Button>
                ))}
              </div>
            </div>
            
            {/* Kid Selection */}
            <div className="flex items-center gap-2 flex-wrap">
              <Checkbox 
                id="assign-all"
                checked={assignToAll}
                onCheckedChange={(checked) => {
                  setAssignToAll(checked === true);
                  if (checked) setSelectedKidIds([]);
                }}
                data-testid="checkbox-all-kids"
              />
              <label htmlFor="assign-all" className="text-xs cursor-pointer">
                All Kids
              </label>
              {!assignToAll && kids.length > 0 && (
                <>
                  {kids.map(kid => {
                    const config = getAvatarConfig(kid.avatar);
                    const isSelected = selectedKidIds.includes(kid.id);
                    return (
                      <Button
                        key={kid.id}
                        variant={isSelected ? "default" : "outline"}
                        size="sm"
                        onClick={() => toggleKidSelection(kid.id)}
                        className={isSelected ? `bg-gradient-to-br ${config.color} text-white border-0` : ""}
                        data-testid={`toggle-kid-${kid.id}`}
                      >
                        <AvatarIcon avatar={kid.avatar} className="w-3 h-3 mr-1" />
                        {kid.name}
                      </Button>
                    );
                  })}
                </>
              )}
              {!assignToAll && kids.length === 0 && (
                <span className="text-xs text-muted-foreground">Add kids first.</span>
              )}
            </div>

            {/* Add button - full width */}
            <Button 
              variant="secondary"
              className="w-full"
              onClick={addVideo} 
              disabled={createVideoMutation.isPending || isResolvingUrl}
              data-testid="button-add-video"
            >
              {(createVideoMutation.isPending || isResolvingUrl) ? (
                <Loader2 className="w-3 h-3 mr-1 animate-spin" />
              ) : (
                <Plus className="w-3 h-3 mr-1" />
              )}
              {isResolvingUrl ? "Resolving..." : "Add"}
            </Button>
          </CardContent>
        </Card>

        {/* Video Preview Dialog */}
        <Dialog open={previewingVideoId !== null} onOpenChange={(open) => !open && setPreviewingVideoId(null)}>
          <DialogContent className={(() => {
            const previewVideo = previewingVideoId ? videos.find(v => v.id === previewingVideoId) : null;
            return previewVideo?.platform === "tiktok" 
              ? "max-w-[90vw] sm:max-w-[400px] p-2" 
              : "max-w-[95vw] sm:max-w-5xl p-2";
          })()}>
            <DialogHeader className="pb-1">
              <DialogTitle className="flex items-center gap-2 text-sm">
                <Play className="w-3 h-3" />
                Preview
              </DialogTitle>
            </DialogHeader>
            {(() => {
              const previewVideo = previewingVideoId ? videos.find(v => v.id === previewingVideoId) : null;
              if (!previewVideo) {
                return (
                  <div className="text-center py-8">
                    <p className="text-muted-foreground">Video not found</p>
                  </div>
                );
              }
              return (
                <div className={`bg-black rounded-lg overflow-hidden ${previewVideo.platform === "tiktok" ? "h-[80vh]" : "aspect-video w-full"}`}>
                  {previewVideo.platform === "tiktok" ? (
                    <iframe
                      width="100%"
                      height="100%"
                      src={`https://www.tiktok.com/embed/v2/${previewVideo.ytId}`}
                      title="TikTok video preview"
                      frameBorder="0"
                      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture; fullscreen"
                      allowFullScreen
                    />
                  ) : (
                    <iframe
                      width="100%"
                      height="100%"
                      src={`https://www.youtube.com/embed/${previewVideo.ytId}?autoplay=1&rel=0`}
                      title="YouTube video preview"
                      frameBorder="0"
                      allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
                      allowFullScreen
                    />
                  )}
                </div>
              );
            })()}
          </DialogContent>
        </Dialog>

        {/* Video Library */}
        <Card>
          <CardHeader className="pb-2">
            <CardTitle className="text-sm flex items-center gap-2">
              <Video className="w-4 h-4 text-purple-500" />
              Video Library ({videos.length})
            </CardTitle>
          </CardHeader>
          <CardContent className="pt-0">
            {videos.length === 0 ? (
              <div className="text-center py-4">
                <div className="w-10 h-10 mx-auto mb-2 rounded-full bg-purple-100 dark:bg-purple-900 flex items-center justify-center">
                  <Youtube className="w-5 h-5 text-purple-500" />
                </div>
                <p className="text-xs text-muted-foreground">No videos yet. Add a YouTube or TikTok link above!</p>
              </div>
            ) : (
              <div className="space-y-3">
                {/* Group by folders */}
                {[
                  { id: "unfiled", name: "Unfiled", videos: videos.filter(v => !v.folderId), isGlobal: false },
                  ...folders
                    .filter(folder => {
                      if (isMaster && folder.name.startsWith("__global_")) return false;
                      return true;
                    })
                    .map(folder => {
                    const globalMatch = folder.name.match(/^__global_(.+)$/);
                    const masterPlaylist = globalMatch ? globalPlaylists.find(gp => gp.id === globalMatch[1]) : null;
                    return {
                      id: folder.id,
                      name: masterPlaylist ? masterPlaylist.name : (globalMatch ? "Curated Playlist" : folder.name),
                      videos: videos.filter(v => v.folderId === folder.id),
                      isGlobal: !!globalMatch,
                    };
                  })
                ].filter(group => group.videos.length > 0).map(group => (
                  <div key={group.id} className="border rounded-lg overflow-hidden">
                    {/* Folder header */}
                    <button
                      onClick={() => toggleFolder(group.id)}
                      className="w-full flex items-center gap-2 p-2 bg-muted/50 text-left"
                      data-testid={`button-toggle-folder-${group.id}`}
                    >
                      {expandedFolders.has(group.id) ? (
                        <ChevronDown className="w-4 h-4" />
                      ) : (
                        <ChevronRight className="w-4 h-4" />
                      )}
                      <FolderIcon className={`w-4 h-4 ${group.isGlobal ? 'text-blue-500' : 'text-purple-500'}`} />
                      <span className="text-sm font-medium">{group.name}</span>
                      {group.isGlobal && (
                        <Badge variant="secondary" className="text-xs">
                          <Globe className="w-3 h-3 mr-0.5" />
                          Curated
                        </Badge>
                      )}
                      <Badge variant="secondary" className="text-xs ml-auto">
                        {group.videos.length}
                      </Badge>
                    </button>
                    
                    {/* Videos in folder */}
                    {expandedFolders.has(group.id) && (
                      <div className="p-2 space-y-2">
                        {group.videos.map(video => {
                          const viewCount = video.totalViews || 0;
                          const isMaxed = viewCount >= MAX_VIDEO_VIEWS;
                          const assignedKidNames = kids
                            .filter(k => video.assigned?.[k.id])
                            .map(k => k.name)
                            .join(", ");
                          
                          return (
                            <div
                              key={video.id}
                              className={`flex items-center gap-2 p-2 rounded-lg ${isMaxed ? 'bg-red-50 dark:bg-red-950/20' : 'bg-muted/30'}`}
                            >
                              {/* Thumbnail with preview button */}
                              <button
                                onClick={() => setPreviewingVideoId(video.id)}
                                className="w-16 h-10 rounded-md overflow-hidden bg-gray-200 dark:bg-gray-800 shrink-0 relative group"
                                data-testid={`button-preview-${video.id}`}
                              >
                                {video.platform === "tiktok" ? (
                                  <TikTokThumbnail videoId={video.ytId} className="w-full h-full" />
                                ) : (
                                  <img
                                    src={`https://img.youtube.com/vi/${video.ytId}/mqdefault.jpg`}
                                    alt="Video thumbnail"
                                    className="w-full h-full object-cover"
                                    onError={(e) => {
                                      e.currentTarget.style.display = 'none';
                                    }}
                                  />
                                )}
                                <div className="absolute inset-0 bg-black/50 flex items-center justify-center opacity-0 group-hover:opacity-100 transition-opacity">
                                  <Play className="w-4 h-4 text-white" />
                                </div>
                                {isMaxed && (
                                  <div className="absolute inset-0 bg-black/50 flex items-center justify-center">
                                    <AlertTriangle className="w-4 h-4 text-red-400" />
                                  </div>
                                )}
                              </button>
                              <div className="flex-1 min-w-0">
                                <p className="text-xs font-mono text-muted-foreground truncate">{video.ytId}</p>
                                <div className="flex flex-wrap items-center gap-1 mt-0.5">
                                  <Popover>
                                    <PopoverTrigger asChild>
                                      <button
                                        className="inline-flex items-center rounded-full border px-2 py-0.5 text-xs font-semibold transition-colors bg-primary/10 border-primary/30 text-primary hover:bg-primary/20"
                                        data-testid={`button-level-${video.id}`}
                                        title="Tap to change level"
                                      >
                                        Lv.{video.priority || 5}
                                      </button>
                                    </PopoverTrigger>
                                    <PopoverContent className="w-auto p-2" align="start">
                                      <div className="grid grid-cols-5 gap-1">
                                        {[1, 2, 3, 4, 5, 6, 7, 8, 9].map((level) => (
                                          <button
                                            key={level}
                                            className={`w-8 h-8 rounded-md text-sm font-medium transition-colors ${
                                              (video.priority || 5) === level
                                                ? 'bg-primary text-primary-foreground'
                                                : 'bg-muted hover:bg-primary/20'
                                            }`}
                                            onClick={() => {
                                              updateVideoMutation.mutate({ videoId: video.id, priority: level });
                                            }}
                                            data-testid={`button-level-${video.id}-${level}`}
                                          >
                                            {level}
                                          </button>
                                        ))}
                                      </div>
                                    </PopoverContent>
                                  </Popover>
                                  <Badge variant={isMaxed ? "destructive" : "outline"} className="text-xs" data-testid={`badge-views-${video.id}`}>
                                    <Eye className="w-2 h-2 mr-0.5" />
                                    {viewCount}/{MAX_VIDEO_VIEWS}
                                  </Badge>
                                  {assignedKidNames && (
                                    <Badge variant="secondary" className="text-xs" data-testid={`badge-assigned-${video.id}`}>
                                      {assignedKidNames}
                                    </Badge>
                                  )}
                                  {/* Voice recordings from kids - show all recordings */}
                                  {kids.flatMap(kid => {
                                    const progress = video.progress?.[kid.id];
                                    if (!progress) return [];
                                    
                                    // Get all recordings (new array format + legacy single)
                                    const recordings: Array<{audioData?: string; recordedAt: string; duration: number}> = [];
                                    if (progress.voiceRecordings) {
                                      recordings.push(...progress.voiceRecordings);
                                    } else if (progress.voiceRecording?.audioData) {
                                      recordings.push(progress.voiceRecording);
                                    }
                                    
                                    return recordings.filter(r => r.audioData).map((recording, idx) => (
                                      <Button
                                        key={`audio-${kid.id}-${idx}`}
                                        variant="outline"
                                        size="sm"
                                        className="h-6 px-2 text-xs bg-green-50 dark:bg-green-950 border-green-300 dark:border-green-700 text-green-700 dark:text-green-300"
                                        onClick={() => {
                                          try {
                                            const audio = new Audio(recording.audioData);
                                            audio.play().catch(err => {
                                              console.error('Audio play failed:', err);
                                              toast({ title: "Could not play recording", variant: "destructive" });
                                            });
                                          } catch (err) {
                                            console.error('Audio creation failed:', err);
                                            toast({ title: "Could not play recording", variant: "destructive" });
                                          }
                                        }}
                                        data-testid={`button-play-recording-${video.id}-${kid.id}-${idx}`}
                                      >
                                        <Mic className="w-3 h-3 mr-1" />
                                        {kid.name}{recordings.length > 1 ? ` #${idx + 1}` : ''}
                                      </Button>
                                    ));
                                  })}
                                </div>
                              </div>
                              <div className="flex items-center gap-1 shrink-0">
                                <Popover>
                                  <PopoverTrigger asChild>
                                    <Button
                                      variant="outline"
                                      size="icon"
                                      data-testid={`button-move-folder-${video.id}`}
                                      title="Move to folder"
                                    >
                                      <FolderPlus className="w-3 h-3" />
                                    </Button>
                                  </PopoverTrigger>
                                  <PopoverContent className="w-48 p-2" align="end">
                                    <p className="text-xs font-medium text-muted-foreground mb-2">Move to folder</p>
                                    <div className="space-y-1">
                                      {video.folderId && (
                                        <Button
                                          variant="ghost"
                                          size="sm"
                                          className="w-full justify-start gap-2 text-xs"
                                          onClick={() => {
                                            updateVideoMutation.mutate({ videoId: video.id, folderId: null });
                                            toast({ title: "Moved to Unfiled" });
                                          }}
                                          data-testid={`button-move-unfiled-${video.id}`}
                                        >
                                          <FolderIcon className="w-3 h-3 text-muted-foreground" />
                                          Unfiled
                                        </Button>
                                      )}
                                      {folders
                                        .filter(f => !f.name.startsWith("__global_") && f.id !== video.folderId)
                                        .map(folder => (
                                          <Button
                                            key={folder.id}
                                            variant="ghost"
                                            size="sm"
                                            className="w-full justify-start gap-2 text-xs"
                                            onClick={() => {
                                              updateVideoMutation.mutate({ videoId: video.id, folderId: folder.id });
                                              toast({ title: `Moved to ${folder.name}` });
                                            }}
                                            data-testid={`button-move-to-${folder.id}-${video.id}`}
                                          >
                                            <FolderIcon className="w-3 h-3 text-purple-500" />
                                            {folder.name}
                                          </Button>
                                        ))
                                      }
                                      {folders.filter(f => !f.name.startsWith("__global_") && f.id !== video.folderId).length === 0 && !video.folderId && (
                                        <p className="text-xs text-muted-foreground p-1.5">No folders yet. Create one first.</p>
                                      )}
                                    </div>
                                  </PopoverContent>
                                </Popover>
                                <Button
                                  variant="outline"
                                  size="icon"
                                  onClick={() => setPreviewingVideoId(video.id)}
                                  data-testid={`button-preview-icon-${video.id}`}
                                >
                                  <Play className="w-3 h-3" />
                                </Button>
                                <Button
                                  variant="destructive"
                                  size="icon"
                                  onClick={() => removeVideo(video.id)}
                                  disabled={deleteVideoMutation.isPending}
                                  data-testid={`button-delete-${video.id}`}
                                >
                                  {deleteVideoMutation.isPending ? (
                                    <Loader2 className="w-3 h-3 animate-spin" />
                                  ) : (
                                    <Trash2 className="w-3 h-3" />
                                  )}
                                </Button>
                              </div>
                            </div>
                          );
                        })}
                      </div>
                    )}
                  </div>
                ))}
              </div>
            )}
          </CardContent>
        </Card>

        {/* Delete Folder Confirmation Dialog */}
        <AlertDialog open={deletingFolderId !== null} onOpenChange={(open) => !open && setDeletingFolderId(null)}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Delete Folder?</AlertDialogTitle>
              <AlertDialogDescription>
                Are you sure you want to delete this folder? Videos in this folder will be moved to "Unfiled".
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel data-testid="button-cancel-delete-folder">Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={() => deletingFolderId && deleteFolderMutation.mutate(deletingFolderId)}
                disabled={deleteFolderMutation.isPending}
                data-testid="button-confirm-delete-folder"
              >
                {deleteFolderMutation.isPending ? "Deleting..." : "Delete"}
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>

        {/* Activity Stats Dialog */}
        <Dialog open={activityStatsKidId !== null} onOpenChange={(open) => !open && setActivityStatsKidId(null)}>
          <DialogContent className="max-w-md">
            {activityStatsKidId && (() => {
              const kid = kids.find(k => k.id === activityStatsKidId);
              if (!kid) return null;
              const stats = getDetailedActivityStats(activityStatsKidId);
              const avatarConfig = getAvatarConfig(kid.avatar);
              return (
                <>
                  <DialogHeader>
                    <DialogTitle className="flex items-center gap-2">
                      <div className={`w-8 h-8 rounded-full bg-gradient-to-br ${avatarConfig.color} flex items-center justify-center text-white`}>
                        <AvatarIcon avatar={kid.avatar} className="w-4 h-4" />
                      </div>
                      {kid.name}'s Activity
                    </DialogTitle>
                  </DialogHeader>
                  
                  <div className="space-y-4">
                    {/* Overall Progress */}
                    <div className="bg-gradient-to-r from-purple-50 to-pink-50 dark:from-purple-900/20 dark:to-pink-900/20 rounded-lg p-4">
                      <div className="text-center mb-2">
                        <div className="text-3xl font-bold text-purple-600 dark:text-purple-400">{stats.completionRate}%</div>
                        <div className="text-xs text-muted-foreground">Overall Completion</div>
                      </div>
                      <div className="w-full bg-gray-200 dark:bg-gray-700 rounded-full h-2">
                        <div 
                          className="bg-gradient-to-r from-purple-500 to-pink-500 h-2 rounded-full transition-all"
                          style={{ width: `${stats.completionRate}%` }}
                        />
                      </div>
                      <div className="flex justify-between text-xs mt-1 text-muted-foreground">
                        <span>{stats.totalCompleted} completed</span>
                        <span>{stats.pending} pending</span>
                      </div>
                    </div>

                    {/* Time Period Stats */}
                    <div className="grid grid-cols-3 gap-2">
                      <button 
                        onClick={() => stats.completedToday > 0 && setActivityDetailView({ kidId: activityStatsKidId!, period: 'today' })}
                        className={`bg-blue-50 dark:bg-blue-900/20 rounded-lg p-3 text-center transition-all ${stats.completedToday > 0 ? 'hover-elevate cursor-pointer' : 'opacity-50'}`}
                        disabled={stats.completedToday === 0}
                        data-testid="button-activity-today"
                      >
                        <div className="text-2xl font-bold text-blue-600 dark:text-blue-400">{stats.completedToday}</div>
                        <div className="text-xs text-muted-foreground">Today</div>
                      </button>
                      <button 
                        onClick={() => stats.completedThisWeek > 0 && setActivityDetailView({ kidId: activityStatsKidId!, period: 'week' })}
                        className={`bg-green-50 dark:bg-green-900/20 rounded-lg p-3 text-center transition-all ${stats.completedThisWeek > 0 ? 'hover-elevate cursor-pointer' : 'opacity-50'}`}
                        disabled={stats.completedThisWeek === 0}
                        data-testid="button-activity-week"
                      >
                        <div className="text-2xl font-bold text-green-600 dark:text-green-400">{stats.completedThisWeek}</div>
                        <div className="text-xs text-muted-foreground">Last 7 Days</div>
                      </button>
                      <button 
                        onClick={() => stats.completedThisMonth > 0 && setActivityDetailView({ kidId: activityStatsKidId!, period: 'month' })}
                        className={`bg-orange-50 dark:bg-orange-900/20 rounded-lg p-3 text-center transition-all ${stats.completedThisMonth > 0 ? 'hover-elevate cursor-pointer' : 'opacity-50'}`}
                        disabled={stats.completedThisMonth === 0}
                        data-testid="button-activity-month"
                      >
                        <div className="text-2xl font-bold text-orange-600 dark:text-orange-400">{stats.completedThisMonth}</div>
                        <div className="text-xs text-muted-foreground">This Month</div>
                      </button>
                    </div>

                    {/* Last 7 Days Chart */}
                    <div>
                      <h4 className="text-sm font-medium mb-2">Last 7 Days</h4>
                      <div className="flex items-end gap-1 h-24">
                        {[...stats.last7Days].reverse().map((day, i) => {
                          const isToday = i === 0;
                          const daysAgo = i; // 0 = today, 1 = yesterday, etc
                          const maxCount = Math.max(...stats.last7Days.map(d => d.count), 1);
                          const height = day.count > 0 ? Math.max((day.count / maxCount) * 100, 15) : 8;
                          const handleDayClick = () => {
                            if (day.count > 0) {
                              const targetDate = new Date();
                              targetDate.setDate(targetDate.getDate() - daysAgo);
                              setActivityDetailView({ kidId: activityStatsKidId!, period: 'day', date: targetDate });
                            }
                          };
                          return (
                            <button 
                              key={i} 
                              className={`flex-1 flex flex-col items-center ${day.count > 0 ? 'cursor-pointer' : 'opacity-50'}`}
                              onClick={handleDayClick}
                              disabled={day.count === 0}
                              data-testid={`button-activity-day-${i}`}
                            >
                              <div className="text-lg font-bold text-purple-600 dark:text-purple-400 mb-1">
                                {day.count}
                              </div>
                              <div 
                                className={`w-full rounded-t transition-all ${day.count > 0 ? 'bg-gradient-to-t from-purple-500 to-pink-400' : 'bg-gray-200 dark:bg-gray-700'}`}
                                style={{ height: `${height}%` }}
                                title={`${day.date}: ${day.count} videos`}
                              />
                              <div className="text-[9px] text-muted-foreground mt-1 truncate w-full text-center">
                                {isToday ? 'Today' : day.date.split(' ')[0]}
                              </div>
                            </button>
                          );
                        })}
                      </div>
                    </div>

                    {/* Summary Stats */}
                    <div className="border-t pt-3">
                      <div className="grid grid-cols-2 gap-2 text-sm">
                        <div className="flex justify-between">
                          <span className="text-muted-foreground">Total Assigned:</span>
                          <span className="font-medium">{stats.totalAssigned}</span>
                        </div>
                        <div className="flex justify-between">
                          <span className="text-muted-foreground">Completed:</span>
                          <span className="font-medium text-green-600">{stats.totalCompleted}</span>
                        </div>
                      </div>
                    </div>
                  </div>
                </>
              );
            })()}
          </DialogContent>
        </Dialog>

        {/* Activity Detail View Dialog */}
        <Dialog open={activityDetailView !== null} onOpenChange={(open) => {
          if (!open) {
            // Cleanup audio playback when closing
            if (activityAudioRef.current) {
              activityAudioRef.current.pause();
              activityAudioRef.current = null;
            }
            setPlayingAudioId(null);
            setActivityDetailView(null);
          }
        }}>
          <DialogContent className="max-w-lg max-h-[80vh] overflow-y-auto">
            {activityDetailView && (() => {
              const kid = kids.find(k => k.id === activityDetailView.kidId);
              if (!kid) return null;
              const periodVideos = getVideosForPeriod(activityDetailView.kidId, activityDetailView.period, activityDetailView.date) as VideoType[];
              const avatarConfig = getAvatarConfig(kid.avatar);
              
              const getPeriodTitle = () => {
                if (activityDetailView.period === 'today') return "Today's Videos";
                if (activityDetailView.period === 'week') return "Last 7 Days' Videos";
                if (activityDetailView.period === 'month') return "This Month's Videos";
                if (activityDetailView.period === 'day' && activityDetailView.date) {
                  const isToday = new Date().toDateString() === activityDetailView.date.toDateString();
                  if (isToday) return "Today's Videos";
                  return activityDetailView.date.toLocaleDateString('en-US', { weekday: 'long', month: 'short', day: 'numeric' });
                }
                return "Videos";
              };
              
              return (
                <>
                  <DialogHeader>
                    <DialogTitle className="flex items-center gap-2">
                      <Button 
                        variant="ghost" 
                        size="icon" 
                        className="h-8 w-8"
                        onClick={() => setActivityDetailView(null)}
                        data-testid="button-back-to-stats"
                      >
                        <ArrowLeft className="w-4 h-4" />
                      </Button>
                      <div className={`w-6 h-6 rounded-full bg-gradient-to-br ${avatarConfig.color} flex items-center justify-center text-white`}>
                        <AvatarIcon avatar={kid.avatar} className="w-3 h-3" />
                      </div>
                      {getPeriodTitle()}
                    </DialogTitle>
                  </DialogHeader>
                  
                  <div className="space-y-3">
                    {periodVideos.length === 0 ? (
                      <div className="text-center text-muted-foreground py-8">
                        No videos watched in this period
                      </div>
                    ) : (
                      periodVideos.map((video: VideoType) => {
                        const progress = video.progress?.[activityDetailView.kidId];
                        const recordings = progress?.voiceRecordings || (progress?.voiceRecording ? [progress.voiceRecording] : []);
                        const watchedAt = progress?.watchedAt ? new Date(progress.watchedAt) : null;
                        
                        return (
                          <div key={video.id} className="flex gap-3 p-2 rounded-lg bg-muted/30" data-testid={`activity-video-${video.id}`}>
                            {/* Video Thumbnail - clickable to preview */}
                            <button
                              onClick={() => {
                                // Cleanup audio playback before opening video
                                if (activityAudioRef.current) {
                                  activityAudioRef.current.pause();
                                  activityAudioRef.current = null;
                                }
                                setPlayingAudioId(null);
                                setActivityDetailView(null);
                                setPreviewingVideoId(video.id);
                              }}
                              className="relative flex-shrink-0 w-24 h-16 rounded overflow-hidden hover-elevate"
                              data-testid={`button-play-video-${video.id}`}
                            >
                              <img
                                src={video.platform === 'youtube' 
                                  ? `https://img.youtube.com/vi/${video.ytId}/mqdefault.jpg`
                                  : `https://www.tiktok.com/api/img/?itemId=${video.ytId}`
                                }
                                alt={`Video ${video.ytId.slice(0, 8)}`}
                                className="w-full h-full object-cover"
                                onError={(e) => {
                                  (e.target as HTMLImageElement).src = 'data:image/svg+xml,<svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 120 90"><rect fill="%23333" width="120" height="90"/><text x="50%" y="50%" fill="%23999" text-anchor="middle" dy=".3em" font-size="12">Video</text></svg>';
                                }}
                              />
                              <div className="absolute inset-0 flex items-center justify-center bg-black/30">
                                <Play className="w-6 h-6 text-white" />
                              </div>
                            </button>
                            
                            {/* Video Info & Audio */}
                            <div className="flex-1 min-w-0">
                              <div className="text-sm font-medium truncate">Video {video.ytId.slice(0, 8)}</div>
                              {watchedAt && (
                                <div className="text-xs text-muted-foreground">
                                  {watchedAt.toLocaleTimeString('en-US', { hour: 'numeric', minute: '2-digit' })}
                                </div>
                              )}
                              
                              {/* Audio Recordings */}
                              {recordings.length > 0 && (
                                <div className="flex flex-wrap gap-1 mt-1">
                                  {recordings.map((rec, idx) => {
                                    const audioId = `${video.id}-${idx}`;
                                    const isPlaying = playingAudioId === audioId;
                                    return (
                                      <Button
                                        key={idx}
                                        size="sm"
                                        variant={isPlaying ? "default" : "outline"}
                                        className="h-7 px-2 text-xs"
                                        onClick={() => {
                                          if (isPlaying) {
                                            activityAudioRef.current?.pause();
                                            setPlayingAudioId(null);
                                          } else {
                                            if (activityAudioRef.current) {
                                              activityAudioRef.current.pause();
                                            }
                                            const audio = new Audio(rec.audioData);
                                            activityAudioRef.current = audio;
                                            audio.onended = () => setPlayingAudioId(null);
                                            audio.play();
                                            setPlayingAudioId(audioId);
                                          }
                                        }}
                                        data-testid={`button-play-audio-${video.id}-${idx}`}
                                      >
                                        {isPlaying ? <Square className="w-3 h-3 mr-1" /> : <Mic className="w-3 h-3 mr-1" />}
                                        {Math.round(rec.duration)}s
                                      </Button>
                                    );
                                  })}
                                </div>
                              )}
                            </div>
                          </div>
                        );
                      })
                    )}
                  </div>
                </>
              );
            })()}
          </DialogContent>
        </Dialog>

        {/* Delete Video Confirmation Dialog */}
        <AlertDialog open={deletingVideoId !== null} onOpenChange={(open) => !open && setDeletingVideoId(null)}>
          <AlertDialogContent>
            <AlertDialogHeader>
              <AlertDialogTitle>Delete Video?</AlertDialogTitle>
              <AlertDialogDescription>
                Are you sure you want to remove this video from the library? This action cannot be undone.
              </AlertDialogDescription>
            </AlertDialogHeader>
            <AlertDialogFooter>
              <AlertDialogCancel data-testid="button-cancel-delete-video">Cancel</AlertDialogCancel>
              <AlertDialogAction
                onClick={() => deletingVideoId && deleteVideoMutation.mutate(deletingVideoId)}
                disabled={deleteVideoMutation.isPending}
                data-testid="button-confirm-delete-video"
              >
                {deleteVideoMutation.isPending ? "Deleting..." : "Delete"}
              </AlertDialogAction>
            </AlertDialogFooter>
          </AlertDialogContent>
        </AlertDialog>
      </div>
    </div>
  );
}


========================================
FILE: client/src/pages/landing.tsx
========================================
import { Button } from "@/components/ui/button";
import { Card, CardContent } from "@/components/ui/card";
import { Video, Folder, Mic, Shield, Users, BarChart3 } from "lucide-react";

export default function Landing() {
  return (
    <div className="min-h-screen bg-gradient-to-b from-background to-muted/30">
      <header className="fixed top-0 left-0 right-0 z-50 backdrop-blur-md bg-background/80 border-b">
        <div className="container mx-auto px-4 h-16 flex items-center justify-between">
          <div className="flex items-center gap-2">
            <div className="w-8 h-8 rounded-lg bg-gradient-to-br from-purple-500 to-pink-500 flex items-center justify-center">
              <Video className="w-4 h-4 text-white" />
            </div>
            <span className="font-bold text-lg">KidVid</span>
          </div>
          <Button asChild data-testid="button-login-header">
            <a href="/api/login">Sign In</a>
          </Button>
        </div>
      </header>

      <main className="pt-24 pb-16">
        <section className="container mx-auto px-4 py-16 text-center">
          <h1 className="text-4xl md:text-5xl lg:text-6xl font-serif font-bold mb-6 bg-gradient-to-r from-purple-600 to-pink-600 bg-clip-text text-transparent">
            Safe Video Learning for Kids
          </h1>
          <p className="text-lg md:text-xl text-muted-foreground max-w-2xl mx-auto mb-8">
            Parents curate YouTube and TikTok videos into organized folders. 
            Kids watch in a distraction-free environment and record what they learned.
          </p>
          <div className="flex flex-col sm:flex-row gap-4 justify-center mb-8">
            <Button size="lg" asChild className="text-lg px-8" data-testid="button-get-started">
              <a href="/api/login">Get Started Free</a>
            </Button>
          </div>
          <p className="text-sm text-muted-foreground">
            Free forever. No credit card required.
          </p>
        </section>

        <section className="container mx-auto px-4 py-16">
          <h2 className="text-2xl md:text-3xl font-bold text-center mb-12">
            Everything You Need
          </h2>
          <div className="grid md:grid-cols-2 lg:grid-cols-3 gap-6 max-w-5xl mx-auto">
            <Card className="hover-elevate">
              <CardContent className="pt-6">
                <div className="w-12 h-12 rounded-lg bg-purple-100 dark:bg-purple-900/30 flex items-center justify-center mb-4">
                  <Folder className="w-6 h-6 text-purple-600 dark:text-purple-400" />
                </div>
                <h3 className="font-semibold text-lg mb-2">Organize by Topics</h3>
                <p className="text-muted-foreground text-sm">
                  Create folders to organize videos by subject, like "Science" or "History". 
                  Set priority levels for progressive learning.
                </p>
              </CardContent>
            </Card>

            <Card className="hover-elevate">
              <CardContent className="pt-6">
                <div className="w-12 h-12 rounded-lg bg-pink-100 dark:bg-pink-900/30 flex items-center justify-center mb-4">
                  <Users className="w-6 h-6 text-pink-600 dark:text-pink-400" />
                </div>
                <h3 className="font-semibold text-lg mb-2">Up to 6 Kids</h3>
                <p className="text-muted-foreground text-sm">
                  Add profiles for each child with unique avatars. 
                  Assign specific videos to each kid or share with everyone.
                </p>
              </CardContent>
            </Card>

            <Card className="hover-elevate">
              <CardContent className="pt-6">
                <div className="w-12 h-12 rounded-lg bg-blue-100 dark:bg-blue-900/30 flex items-center justify-center mb-4">
                  <Shield className="w-6 h-6 text-blue-600 dark:text-blue-400" />
                </div>
                <h3 className="font-semibold text-lg mb-2">Safe Kid Mode</h3>
                <p className="text-muted-foreground text-sm">
                  Kids only see their assigned videos. No ads, no distractions, 
                  no wandering to random content.
                </p>
              </CardContent>
            </Card>

            <Card className="hover-elevate">
              <CardContent className="pt-6">
                <div className="w-12 h-12 rounded-lg bg-green-100 dark:bg-green-900/30 flex items-center justify-center mb-4">
                  <Mic className="w-6 h-6 text-green-600 dark:text-green-400" />
                </div>
                <h3 className="font-semibold text-lg mb-2">Voice Recordings</h3>
                <p className="text-muted-foreground text-sm">
                  Kids record what they learned after watching. 
                  Parents can play back recordings to check understanding.
                </p>
              </CardContent>
            </Card>

            <Card className="hover-elevate">
              <CardContent className="pt-6">
                <div className="w-12 h-12 rounded-lg bg-orange-100 dark:bg-orange-900/30 flex items-center justify-center mb-4">
                  <BarChart3 className="w-6 h-6 text-orange-600 dark:text-orange-400" />
                </div>
                <h3 className="font-semibold text-lg mb-2">Track Progress</h3>
                <p className="text-muted-foreground text-sm">
                  See detailed activity stats: videos watched today, this week, 
                  completion rates, and 7-day charts.
                </p>
              </CardContent>
            </Card>

            <Card className="hover-elevate">
              <CardContent className="pt-6">
                <div className="w-12 h-12 rounded-lg bg-cyan-100 dark:bg-cyan-900/30 flex items-center justify-center mb-4">
                  <Video className="w-6 h-6 text-cyan-600 dark:text-cyan-400" />
                </div>
                <h3 className="font-semibold text-lg mb-2">YouTube + TikTok</h3>
                <p className="text-muted-foreground text-sm">
                  Add videos from YouTube or TikTok. 
                  Just paste the link and assign to kids.
                </p>
              </CardContent>
            </Card>
          </div>
        </section>

        <section className="container mx-auto px-4 py-16 text-center">
          <div className="max-w-2xl mx-auto">
            <h2 className="text-2xl md:text-3xl font-bold mb-6">
              Ready to Get Started?
            </h2>
            <p className="text-muted-foreground mb-8">
              Create your free account and start curating educational videos for your kids today.
            </p>
            <Button size="lg" asChild className="text-lg px-8" data-testid="button-signup-cta">
              <a href="/api/login">Create Free Account</a>
            </Button>
          </div>
        </section>
      </main>

      <footer className="border-t py-8">
        <div className="container mx-auto px-4 text-center text-sm text-muted-foreground">
          <p>KidVid - Safe video learning for kids</p>
        </div>
      </footer>
    </div>
  );
}


========================================
FILE: client/src/pages/not-found.tsx
========================================
import { Card, CardContent } from "@/components/ui/card";
import { AlertCircle } from "lucide-react";

export default function NotFound() {
  return (
    <div className="min-h-screen w-full flex items-center justify-center bg-gray-50">
      <Card className="w-full max-w-md mx-4">
        <CardContent className="pt-6">
          <div className="flex mb-4 gap-2">
            <AlertCircle className="h-8 w-8 text-red-500" />
            <h1 className="text-2xl font-bold text-gray-900">404 Page Not Found</h1>
          </div>

          <p className="mt-4 text-sm text-gray-600">
            Did you forget to add the page to the router?
          </p>
        </CardContent>
      </Card>
    </div>
  );
}


========================================
FILE: shared/schema.ts
========================================
import { z } from "zod";
import { pgTable, text, varchar, integer, jsonb, timestamp } from "drizzle-orm/pg-core";

// Export auth models
export * from "./models/auth";

// Avatar options for kids - using icon names instead of emojis
export const AVATARS = ["child", "girl", "boy", "baby", "cool", "robot"] as const;

// Avatar display names and colors for UI
export const AVATAR_CONFIG: Record<typeof AVATARS[number], { label: string; color: string }> = {
  child: { label: "Child", color: "from-purple-400 to-pink-400" },
  girl: { label: "Girl", color: "from-pink-400 to-rose-400" },
  boy: { label: "Boy", color: "from-blue-400 to-cyan-400" },
  baby: { label: "Baby", color: "from-yellow-400 to-orange-400" },
  cool: { label: "Cool", color: "from-indigo-400 to-purple-400" },
  robot: { label: "Robot", color: "from-gray-400 to-slate-400" },
};

// Kid schema
export const kidSchema = z.object({
  id: z.string(),
  name: z.string().min(1, "Name is required"),
  avatar: z.enum(AVATARS),
});

export const insertKidSchema = kidSchema.omit({ id: true });

export type Kid = z.infer<typeof kidSchema>;
export type InsertKid = z.infer<typeof insertKidSchema>;

// Voice recording for video completion
export const voiceRecordingSchema = z.object({
  recordedAt: z.string(),
  duration: z.number(), // seconds
  audioData: z.string().optional(), // base64 audio data for playback
});

export type VoiceRecording = z.infer<typeof voiceRecordingSchema>;

// Video progress per kid
export const videoProgressSchema = z.object({
  watched: z.boolean(),
  watchedAt: z.string().optional(),
  voiceRecording: voiceRecordingSchema.optional(), // legacy single recording
  voiceRecordings: z.array(voiceRecordingSchema).optional(), // multiple recordings per kid
  parentReviewed: z.boolean().optional(), // has parent seen this completion?
});

export type VideoProgress = z.infer<typeof videoProgressSchema>;

// Max views per video
export const MAX_VIDEO_VIEWS = 4;

// Supported video platforms
export const VIDEO_PLATFORMS = ["youtube", "tiktok"] as const;
export type VideoPlatform = typeof VIDEO_PLATFORMS[number];

// Folder schema for organizing videos
export const folderSchema = z.object({
  id: z.string(),
  name: z.string().min(1, "Folder name is required"),
});

export const insertFolderSchema = folderSchema.omit({ id: true });

export type Folder = z.infer<typeof folderSchema>;
export type InsertFolder = z.infer<typeof insertFolderSchema>;

// Video priority levels (1 = basic/beginner, 9 = advanced)
export const VIDEO_PRIORITY_MIN = 1;
export const VIDEO_PRIORITY_MAX = 9;
export const VIDEO_PRIORITY_DEFAULT = 5;

// Video schema
export const videoSchema = z.object({
  id: z.string(),
  url: z.string().url("Must be a valid URL"),
  ytId: z.string(), // stores video ID for any platform (YouTube or TikTok)
  platform: z.enum(VIDEO_PLATFORMS).default("youtube"), // video platform type
  folderId: z.string().nullable().optional(), // optional folder assignment
  priority: z.number().min(1).max(9).default(VIDEO_PRIORITY_DEFAULT), // 1=basic, 9=advanced
  assigned: z.record(z.string(), z.boolean()), // kidId -> assigned
  progress: z.record(z.string(), videoProgressSchema), // kidId -> progress
  totalViews: z.number().default(0), // total times video has been watched (max 4)
});

export const insertVideoSchema = z.object({
  url: z.string().url("Must be a valid YouTube or TikTok URL"),
  kidIds: z.array(z.string()).optional(), // if empty/undefined, assign to all kids
  folderId: z.string().nullable().optional(), // optional folder assignment
  priority: z.number().min(1).max(9).default(VIDEO_PRIORITY_DEFAULT), // 1=basic, 9=advanced
});

export type Video = z.infer<typeof videoSchema>;
export type InsertVideo = z.infer<typeof insertVideoSchema>;

// Database tables for Drizzle ORM
export const kidsTable = pgTable("kids", {
  id: varchar("id", { length: 64 }).primaryKey(),
  userId: varchar("user_id", { length: 255 }).notNull(), // Owner user ID
  name: text("name").notNull(),
  avatar: text("avatar").notNull(),
});

export const foldersTable = pgTable("folders", {
  id: varchar("id", { length: 64 }).primaryKey(),
  userId: varchar("user_id", { length: 255 }).notNull(), // Owner user ID
  name: text("name").notNull(),
});

export const videosTable = pgTable("videos", {
  id: varchar("id", { length: 64 }).primaryKey(),
  userId: varchar("user_id", { length: 255 }).notNull(), // Owner user ID
  url: text("url").notNull(),
  ytId: text("yt_id").notNull(), // stores video ID for any platform (removed unique constraint - same video can be added by different users)
  platform: text("platform").notNull().default("youtube"), // youtube or tiktok
  folderId: varchar("folder_id", { length: 64 }),
  priority: integer("priority").notNull().default(5), // 1=basic, 9=advanced
  assigned: jsonb("assigned").notNull().$type<Record<string, boolean>>(),
  progress: jsonb("progress").notNull().$type<Record<string, VideoProgress>>(),
  totalViews: integer("total_views").notNull().default(0),
});

// Global playlist subscriptions - parents subscribe to master's playlists for their kids
export const globalSubscriptionsTable = pgTable("global_subscriptions", {
  id: varchar("id", { length: 64 }).primaryKey(),
  userId: varchar("user_id", { length: 255 }).notNull(),
  masterFolderId: varchar("master_folder_id", { length: 64 }).notNull(),
  kidIds: jsonb("kid_ids").notNull().$type<string[]>(),
  createdAt: timestamp("created_at").defaultNow(),
});

export const globalSubscriptionSchema = z.object({
  id: z.string(),
  userId: z.string(),
  masterFolderId: z.string(),
  kidIds: z.array(z.string()),
  createdAt: z.string().optional(),
});

export const insertGlobalSubscriptionSchema = z.object({
  masterFolderId: z.string().min(1, "Playlist ID is required"),
  kidIds: z.array(z.string()).default([]),
});

export type GlobalSubscription = z.infer<typeof globalSubscriptionSchema>;
export type InsertGlobalSubscription = z.infer<typeof insertGlobalSubscriptionSchema>;

// Feedback table for user feedback with various media types
export const feedbackTable = pgTable("feedback", {
  id: varchar("id", { length: 64 }).primaryKey(),
  userId: varchar("user_id", { length: 255 }).notNull(), // Who submitted
  type: text("type").notNull(), // 'text', 'voice', 'video', 'screenshot'
  content: text("content"), // Text content or URL/base64 data
  createdAt: timestamp("created_at").defaultNow(),
});

export const feedbackSchema = z.object({
  id: z.string(),
  userId: z.string(),
  type: z.enum(["text", "voice", "video", "screenshot"]),
  content: z.string().optional(),
  createdAt: z.string().optional(),
});

export const insertFeedbackSchema = z.object({
  type: z.enum(["text", "voice", "video", "screenshot"]),
  content: z.string(),
});

export type Feedback = z.infer<typeof feedbackSchema>;
export type InsertFeedback = z.infer<typeof insertFeedbackSchema>;

// Helper function to extract YouTube ID from various URL formats
export function getYouTubeId(url: string): string | null {
  try {
    const u = new URL(String(url || "").trim());
    const host = u.hostname.replace("www.", "").toLowerCase();

    if (host === "youtu.be") {
      return u.pathname.split("/").filter(Boolean)[0] || null;
    }

    if (host.includes("youtube.com")) {
      const v = u.searchParams.get("v");
      if (v) return v;

      const parts = u.pathname.split("/").filter(Boolean);
      if (parts[0] === "shorts" && parts[1]) return parts[1];
      if (parts[0] === "embed" && parts[1]) return parts[1];
    }

    return null;
  } catch {
    return null;
  }
}

// Helper function to extract TikTok video ID from various URL formats
// Note: Short URLs (vm.tiktok.com) are NOT supported because they require server-side resolution
// Only full TikTok URLs with numeric video IDs work with embedded playback
export function getTikTokId(url: string): string | null {
  try {
    const u = new URL(String(url || "").trim());
    const host = u.hostname.replace("www.", "").toLowerCase();

    // TikTok URLs: tiktok.com/@user/video/1234567890
    // Short URLs (vm.tiktok.com) are not supported - they contain redirect codes, not video IDs
    if (host === "tiktok.com" || host === "m.tiktok.com") {
      const parts = u.pathname.split("/").filter(Boolean);
      // Format: /@username/video/videoId
      const videoIndex = parts.indexOf("video");
      if (videoIndex !== -1 && parts[videoIndex + 1]) {
        const videoId = parts[videoIndex + 1];
        // Verify it looks like a numeric TikTok video ID
        if (/^\d+$/.test(videoId)) {
          return videoId;
        }
      }
    }

    return null;
  } catch {
    return null;
  }
}

// Helper to detect video platform and extract ID
export function getVideoInfo(url: string): { platform: VideoPlatform; videoId: string } | null {
  const youtubeId = getYouTubeId(url);
  if (youtubeId) {
    return { platform: "youtube", videoId: youtubeId };
  }

  const tiktokId = getTikTokId(url);
  if (tiktokId) {
    return { platform: "tiktok", videoId: tiktokId };
  }

  return null;
}


========================================
FILE: shared/models/auth.ts
========================================
import { sql } from "drizzle-orm";
import { index, jsonb, pgTable, timestamp, varchar } from "drizzle-orm/pg-core";

// Session storage table.
// (IMPORTANT) This table is mandatory for Replit Auth, don't drop it.
export const sessions = pgTable(
  "sessions",
  {
    sid: varchar("sid").primaryKey(),
    sess: jsonb("sess").notNull(),
    expire: timestamp("expire").notNull(),
  },
  (table) => [index("IDX_session_expire").on(table.expire)]
);

// User storage table.
// (IMPORTANT) This table is mandatory for Replit Auth, don't drop it.
export const users = pgTable("users", {
  id: varchar("id").primaryKey().default(sql`gen_random_uuid()`),
  email: varchar("email").unique(),
  firstName: varchar("first_name"),
  lastName: varchar("last_name"),
  profileImageUrl: varchar("profile_image_url"),
  createdAt: timestamp("created_at").defaultNow(),
  updatedAt: timestamp("updated_at").defaultNow(),
});

export type UpsertUser = typeof users.$inferInsert;
export type User = typeof users.$inferSelect;


========================================
FILE: server/index.ts
========================================
import express, { type Request, Response, NextFunction } from "express";
import { registerRoutes } from "./routes";
import { serveStatic } from "./static";
import { createServer } from "http";

const app = express();
const httpServer = createServer(app);

declare module "http" {
  interface IncomingMessage {
    rawBody: unknown;
  }
}

app.use(
  express.json({
    limit: '50mb',
    verify: (req, _res, buf) => {
      req.rawBody = buf;
    },
  }),
);

app.use(express.urlencoded({ extended: false }));

export function log(message: string, source = "express") {
  const formattedTime = new Date().toLocaleTimeString("en-US", {
    hour: "numeric",
    minute: "2-digit",
    second: "2-digit",
    hour12: true,
  });

  console.log(`${formattedTime} [${source}] ${message}`);
}

app.use((req, res, next) => {
  const start = Date.now();
  const path = req.path;
  let capturedJsonResponse: Record<string, any> | undefined = undefined;

  const originalResJson = res.json;
  res.json = function (bodyJson, ...args) {
    capturedJsonResponse = bodyJson;
    return originalResJson.apply(res, [bodyJson, ...args]);
  };

  res.on("finish", () => {
    const duration = Date.now() - start;
    if (path.startsWith("/api")) {
      let logLine = `${req.method} ${path} ${res.statusCode} in ${duration}ms`;
      if (capturedJsonResponse) {
        logLine += ` :: ${JSON.stringify(capturedJsonResponse)}`;
      }

      log(logLine);
    }
  });

  next();
});

(async () => {
  await registerRoutes(httpServer, app);

  app.use((err: any, _req: Request, res: Response, next: NextFunction) => {
    const status = err.status || err.statusCode || 500;
    const message = err.message || "Internal Server Error";

    console.error("Internal Server Error:", err);

    if (res.headersSent) {
      return next(err);
    }

    return res.status(status).json({ message });
  });

  // importantly only setup vite in development and after
  // setting up all the other routes so the catch-all route
  // doesn't interfere with the other routes
  if (process.env.NODE_ENV === "production") {
    serveStatic(app);
  } else {
    const { setupVite } = await import("./vite");
    await setupVite(httpServer, app);
  }

  // ALWAYS serve the app on the port specified in the environment variable PORT
  // Other ports are firewalled. Default to 5000 if not specified.
  // this serves both the API and the client.
  // It is the only port that is not firewalled.
  const port = parseInt(process.env.PORT || "5000", 10);
  httpServer.listen(
    {
      port,
      host: "0.0.0.0",
      reusePort: true,
    },
    () => {
      log(`serving on port ${port}`);
    },
  );
})();


========================================
FILE: server/routes.ts
========================================
import type { Express, Request, Response } from "express";
import { type Server } from "http";
import path from "path";
import { storage } from "./storage";
import { insertKidSchema, insertVideoSchema, insertFolderSchema, insertFeedbackSchema, insertGlobalSubscriptionSchema, getVideoInfo, type Kid, videosTable } from "@shared/schema";
import { db } from "./db";
import { eq } from "drizzle-orm";
import { setupAuth, registerAuthRoutes, isAuthenticated } from "./replit_integrations/auth";
import { authStorage } from "./replit_integrations/auth/storage";

async function resolveTikTokShortUrl(shortUrl: string): Promise<string | null> {
  try {
    const response = await fetch(shortUrl, {
      method: 'HEAD',
      redirect: 'follow',
    });
    const finalUrl = response.url;
    
    const videoInfo = getVideoInfo(finalUrl);
    if (videoInfo && videoInfo.platform === 'tiktok') {
      return finalUrl;
    }
    return null;
  } catch (error) {
    console.error('Failed to resolve TikTok short URL:', error);
    return null;
  }
}

function isTikTokShortUrl(url: string): boolean {
  try {
    const u = new URL(url);
    const host = u.hostname.replace('www.', '').toLowerCase();
    return host === 'vm.tiktok.com' || (host === 'tiktok.com' && u.pathname.startsWith('/t/'));
  } catch {
    return false;
  }
}

function getUserId(req: Request): string {
  const sub = (req.user as any)?.claims?.sub;
  return sub ? String(sub) : '';
}

export async function registerRoutes(
  httpServer: Server,
  app: Express
): Promise<Server> {
  await setupAuth(app);
  registerAuthRoutes(app);

  app.get("/api/health", (_req: Request, res: Response) => {
    res.json({ ok: true, time: new Date().toISOString() });
  });

  app.get("/api/trial-status", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const user = await authStorage.getUser(userId);
      if (!user || !user.createdAt) {
        return res.json({ daysLeft: 30, show: false, frozen: false });
      }
      const now = new Date();
      const trialStart = new Date(user.createdAt);
      const msPerDay = 1000 * 60 * 60 * 24;
      const daysSinceStart = Math.floor((now.getTime() - trialStart.getTime()) / msPerDay);
      const totalTrialDays = 30;
      const daysLeft = Math.max(0, totalTrialDays - daysSinceStart);
      const show = daysSinceStart <= totalTrialDays;
      const frozen = daysSinceStart >= 15 && daysSinceStart <= totalTrialDays;
      res.json({ daysLeft, show, frozen });
    } catch (error) {
      console.error("Failed to get trial status:", error);
      res.json({ daysLeft: 0, show: false, frozen: false });
    }
  });

  app.get("/api/debug-session", isAuthenticated, async (req: Request, res: Response) => {
    const user = req.user as any;
    const userId = getUserId(req);
    res.json({
      userId,
      hasClaims: !!user?.claims,
      sub: user?.claims?.sub,
      subType: typeof user?.claims?.sub,
      hasAccessToken: !!user?.access_token,
      expiresAt: user?.expires_at,
      now: Math.floor(Date.now() / 1000),
      isAuthenticated: req.isAuthenticated(),
      sessionId: req.sessionID?.substring(0, 8),
    });
  });

  app.post("/api/resolve-tiktok-url", isAuthenticated, async (req, res) => {
    try {
      const { url } = req.body;
      if (!url || typeof url !== 'string') {
        return res.status(400).json({ error: "URL is required" });
      }
      
      if (!isTikTokShortUrl(url)) {
        return res.status(400).json({ error: "Not a TikTok short URL" });
      }
      
      const resolvedUrl = await resolveTikTokShortUrl(url);
      if (!resolvedUrl) {
        return res.status(400).json({ error: "Could not resolve TikTok URL" });
      }
      
      res.json({ resolvedUrl });
    } catch (error) {
      console.error("Failed to resolve TikTok URL:", error);
      res.status(500).json({ error: "Failed to resolve TikTok URL" });
    }
  });

  app.get("/api/tiktok-thumbnail/:videoId", isAuthenticated, async (req, res) => {
    try {
      const { videoId } = req.params;
      if (!videoId) {
        return res.status(400).json({ error: "Video ID is required" });
      }
      
      const videoUrl = `https://www.tiktok.com/video/${videoId}`;
      const oembedUrl = `https://www.tiktok.com/oembed?url=${encodeURIComponent(videoUrl)}`;
      
      const response = await fetch(oembedUrl, {
        headers: {
          'User-Agent': 'Mozilla/5.0 (compatible; bot/1.0)'
        }
      });
      
      if (!response.ok) {
        const fallbackUrl = `https://www.tiktok.com/@_/video/${videoId}`;
        const fallbackOembed = `https://www.tiktok.com/oembed?url=${encodeURIComponent(fallbackUrl)}`;
        const fallbackRes = await fetch(fallbackOembed);
        
        if (!fallbackRes.ok) {
          return res.status(404).json({ error: "Could not fetch thumbnail" });
        }
        
        const fallbackData = await fallbackRes.json() as { thumbnail_url?: string };
        if (fallbackData.thumbnail_url) {
          return res.json({ thumbnailUrl: fallbackData.thumbnail_url });
        }
        return res.status(404).json({ error: "Thumbnail not found" });
      }
      
      const data = await response.json() as { thumbnail_url?: string };
      if (data.thumbnail_url) {
        res.json({ thumbnailUrl: data.thumbnail_url });
      } else {
        res.status(404).json({ error: "Thumbnail not found" });
      }
    } catch (error) {
      console.error("Failed to fetch TikTok thumbnail:", error);
      res.status(500).json({ error: "Failed to fetch thumbnail" });
    }
  });

  app.get("/api/kids", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      console.log("[GET /api/kids] userId:", JSON.stringify(userId));
      const kids = await storage.getKids(userId);
      console.log("[GET /api/kids] found", kids.length, "kids");
      res.json(kids);
    } catch (error) {
      console.error("Failed to fetch kids:", error);
      res.status(500).json({ error: "Failed to fetch kids" });
    }
  });

  app.post("/api/kids", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      console.log("[POST /api/kids] userId:", JSON.stringify(userId), "body:", JSON.stringify(req.body));
      if (!userId) {
        return res.status(401).json({ error: "No user ID found in session" });
      }
      const parsed = insertKidSchema.safeParse(req.body);
      if (!parsed.success) {
        console.log("[POST /api/kids] validation error:", parsed.error.message);
        return res.status(400).json({ error: parsed.error.message });
      }

      const kids = await storage.getKids(userId);
      if (kids.length >= 6) {
        return res.status(400).json({ error: "Maximum 6 kids allowed" });
      }

      const newName = parsed.data.name.trim().toLowerCase();
      const duplicate = kids.find(k => k.name.trim().toLowerCase() === newName);
      if (duplicate) {
        return res.status(400).json({ error: `A kid named "${parsed.data.name}" already exists` });
      }

      const kid = await storage.createKid(parsed.data, userId);
      console.log("[POST /api/kids] created kid:", JSON.stringify(kid));
      res.status(201).json(kid);
    } catch (error: any) {
      console.error("[POST /api/kids] FAILED:", error?.message, error?.stack);
      res.status(500).json({ error: "Failed to create kid", detail: error?.message });
    }
  });

  app.patch("/api/kids/:id", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const id = req.params.id as string;
      const { name } = req.body;
      if (!name || typeof name !== 'string' || name.trim().length === 0) {
        return res.status(400).json({ error: "Name is required" });
      }
      const kids = await storage.getKids(userId);
      const newName = name.trim().toLowerCase();
      const duplicate = kids.find(k => k.id !== id && k.name.trim().toLowerCase() === newName);
      if (duplicate) {
        return res.status(400).json({ error: `A kid named "${name.trim()}" already exists` });
      }
      const kid = await storage.updateKid(id, userId, { name: name.trim() });
      if (!kid) {
        return res.status(404).json({ error: "Kid not found" });
      }
      res.json(kid);
    } catch (error) {
      res.status(500).json({ error: "Failed to update kid" });
    }
  });

  app.post("/api/kids/cleanup-duplicates", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const kids = await storage.getKids(userId);
      const grouped = new Map<string, Kid[]>();
      for (const kid of kids) {
        const key = kid.name.toLowerCase().trim();
        if (!grouped.has(key)) grouped.set(key, []);
        grouped.get(key)!.push(kid);
      }

      let hasDups = false;
      for (const g of Array.from(grouped.values())) { if (g.length > 1) { hasDups = true; break; } }
      if (!hasDups) return res.json({ removed: 0 });

      const videos = await storage.getVideos(userId);
      const deleteIds: string[] = [];

      for (const group of Array.from(grouped.values())) {
        if (group.length <= 1) continue;
        group.sort((a: Kid, b: Kid) => a.id.localeCompare(b.id));
        const keeper = group[0];
        for (let i = 1; i < group.length; i++) {
          const dupId = group[i].id;
          deleteIds.push(dupId);
          for (const video of videos) {
            if (video.assigned[dupId]) {
              video.assigned[keeper.id] = true;
              delete video.assigned[dupId];
            }
            if (video.progress[dupId]) {
              if (!video.progress[keeper.id]?.watched) {
                video.progress[keeper.id] = video.progress[dupId];
              }
              delete video.progress[dupId];
            }
          }
        }
      }

      for (const video of videos) {
        await db.update(videosTable)
          .set({ assigned: video.assigned, progress: video.progress })
          .where(eq(videosTable.id, video.id));
      }
      for (const dupId of deleteIds) {
        await storage.deleteKid(dupId, userId);
      }
      res.json({ removed: deleteIds.length });
    } catch (error) {
      res.status(500).json({ error: "Failed to clean up duplicates" });
    }
  });

  app.delete("/api/kids/:id", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const id = req.params.id as string;
      const deleted = await storage.deleteKid(id, userId);
      if (!deleted) {
        return res.status(404).json({ error: "Kid not found" });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to delete kid" });
    }
  });

  app.get("/api/folders", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const folders = await storage.getFolders(userId);
      res.json(folders);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch folders" });
    }
  });

  app.post("/api/folders", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const parsed = insertFolderSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.message });
      }
      const folder = await storage.createFolder(parsed.data, userId);
      res.status(201).json(folder);
    } catch (error) {
      res.status(500).json({ error: "Failed to create folder" });
    }
  });

  app.patch("/api/folders/:id", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const id = req.params.id as string;
      const { name } = req.body;
      if (!name || typeof name !== 'string' || name.trim().length === 0) {
        return res.status(400).json({ error: "Name is required" });
      }
      const folder = await storage.updateFolder(id, userId, { name: name.trim() });
      if (!folder) {
        return res.status(404).json({ error: "Folder not found" });
      }
      res.json(folder);
    } catch (error) {
      res.status(500).json({ error: "Failed to update folder" });
    }
  });

  app.delete("/api/folders/:id", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const id = req.params.id as string;
      await storage.deleteFolder(id, userId);
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to delete folder" });
    }
  });

  const masterCleanedUp = new Set<string>();
  app.get("/api/videos", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      if (MASTER_USER_ID && userId === MASTER_USER_ID && !masterCleanedUp.has(userId)) {
        await storage.cleanupGlobalData(userId);
        masterCleanedUp.add(userId);
      }
      if (MASTER_USER_ID && userId !== MASTER_USER_ID) {
        await storage.syncAllSubscriptions(userId, MASTER_USER_ID);
      }
      const videos = await storage.getVideos(userId);
      res.json(videos);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch videos" });
    }
  });

  app.post("/api/videos", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const parsed = insertVideoSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.message });
      }

      const allKids = await storage.getKids(userId);
      const result = await storage.createVideo(parsed.data.url, parsed.data.kidIds, allKids, userId, parsed.data.folderId, parsed.data.priority);
      
      if (!result.video) {
        return res.status(400).json({ error: result.error || "Failed to add video" });
      }

      res.status(201).json(result.video);
    } catch (error) {
      res.status(500).json({ error: "Failed to create video" });
    }
  });

  app.patch("/api/videos/:id", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const id = req.params.id as string;
      const { priority, folderId } = req.body;
      
      const updates: { priority?: number; folderId?: string | null } = {};
      if (priority !== undefined) updates.priority = Math.min(9, Math.max(1, parseInt(priority)));
      if (folderId !== undefined) updates.folderId = folderId;
      
      const video = await storage.updateVideo(id, userId, updates);
      if (!video) {
        return res.status(404).json({ error: "Video not found" });
      }
      res.json(video);
    } catch (error) {
      res.status(500).json({ error: "Failed to update video" });
    }
  });

  app.delete("/api/videos/:id", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const id = req.params.id as string;
      const deleted = await storage.deleteVideo(id, userId);
      if (!deleted) {
        return res.status(404).json({ error: "Video not found" });
      }
      res.status(204).send();
    } catch (error) {
      res.status(500).json({ error: "Failed to delete video" });
    }
  });

  app.post("/api/videos/:videoId/watched/:kidId", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const videoId = req.params.videoId as string;
      const kidId = req.params.kidId as string;
      const { voiceRecording } = req.body;
      
      if (!voiceRecording || typeof voiceRecording.recordedAt !== 'string' || typeof voiceRecording.duration !== 'number' || voiceRecording.duration <= 0) {
        return res.status(400).json({ error: "A valid voice recording with duration > 0 is required to complete the video" });
      }

      const result = await storage.markVideoWatched(videoId, kidId, voiceRecording, userId);
      
      if (!result.video) {
        return res.status(400).json({ error: result.error || "Failed to mark video as watched" });
      }

      res.json(result.video);
    } catch (error) {
      res.status(500).json({ error: "Failed to mark video as watched" });
    }
  });

  app.get("/api/public/kid/:kidId", async (req: Request, res: Response) => {
    try {
      const kidId = req.params.kidId as string;
      const kid = await storage.getKidById(kidId);
      if (!kid) {
        return res.status(404).json({ error: "Kid not found" });
      }
      res.json({ id: kid.id, name: kid.name, avatar: kid.avatar });
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch kid" });
    }
  });

  app.get("/api/public/kid/:kidId/videos", async (req: Request, res: Response) => {
    try {
      const kidId = req.params.kidId as string;
      const kid = await storage.getKidById(kidId);
      if (!kid) {
        return res.status(404).json({ error: "Kid not found" });
      }
      const allVideos = await storage.getVideosByOwner(kid.userId);
      const kidVideos = allVideos.filter(v => v.assigned?.[kidId]);
      res.json(kidVideos);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch videos" });
    }
  });

  app.get("/api/public/kid/:kidId/folders", async (req: Request, res: Response) => {
    try {
      const kidId = req.params.kidId as string;
      const kid = await storage.getKidById(kidId);
      if (!kid) {
        return res.status(404).json({ error: "Kid not found" });
      }
      const folders = await storage.getFoldersByOwner(kid.userId);
      res.json(folders);
    } catch (error) {
      res.status(500).json({ error: "Failed to fetch folders" });
    }
  });

  app.post("/api/public/kid/:kidId/videos/:videoId/watched", async (req: Request, res: Response) => {
    try {
      const kidId = req.params.kidId as string;
      const videoId = req.params.videoId as string;
      const { voiceRecording } = req.body;

      if (!voiceRecording || typeof voiceRecording.recordedAt !== 'string' || typeof voiceRecording.duration !== 'number' || voiceRecording.duration <= 0) {
        return res.status(400).json({ error: "A valid voice recording with duration > 0 is required to complete the video" });
      }

      const kid = await storage.getKidById(kidId);
      if (!kid) {
        return res.status(404).json({ error: "Kid not found" });
      }

      const result = await storage.markVideoWatchedPublic(videoId, kidId, voiceRecording, kid.userId);

      if (!result.video) {
        return res.status(400).json({ error: result.error || "Failed to mark video as watched" });
      }

      res.json(result.video);
    } catch (error) {
      res.status(500).json({ error: "Failed to mark video as watched" });
    }
  });

  // Badge count endpoints
  app.get("/api/badge/parent", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const count = await storage.getBadgeCountForParent(userId);
      res.json({ count });
    } catch (error) {
      res.status(500).json({ error: "Failed to get badge count" });
    }
  });

  app.post("/api/badge/parent/clear", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      await storage.clearParentBadge(userId);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to clear badge" });
    }
  });

  app.get("/api/badge/kid/:kidId", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const kidId = req.params.kidId as string;
      const count = await storage.getBadgeCountForKid(kidId, userId);
      res.json({ count });
    } catch (error) {
      res.status(500).json({ error: "Failed to get badge count" });
    }
  });

  // Public badge endpoint for kid PWA (uses same public kid endpoint pattern)
  app.get("/api/public/kid/:kidId/badge", async (req: Request, res: Response) => {
    try {
      const kidId = req.params.kidId as string;
      if (!kidId || kidId.length < 10) {
        return res.status(404).json({ count: 0 });
      }
      const kid = await storage.getKidById(kidId);
      if (!kid) {
        return res.status(404).json({ count: 0 });
      }
      const count = await storage.getBadgeCountForKid(kidId, kid.userId);
      res.json({ count });
    } catch (error) {
      res.json({ count: 0 });
    }
  });

  app.get("/api/download-icon", (_req: Request, res: Response) => {
    const iconPath = path.resolve(process.cwd(), "client/public/favicon.png");
    res.download(iconPath, "kid-video-app-icon.png", (err) => {
      if (err) {
        res.status(404).json({ error: "Icon not found" });
      }
    });
  });

  const MASTER_USER_ID = process.env.MASTER_USER_ID || '';

  app.get("/api/global/is-master", isAuthenticated, async (req: Request, res: Response) => {
    const userId = getUserId(req);
    res.json({ isMaster: !!MASTER_USER_ID && userId === MASTER_USER_ID });
  });

  app.get("/api/global/playlists", isAuthenticated, async (req: Request, res: Response) => {
    try {
      if (!MASTER_USER_ID) return res.json([]);
      const foldersWithCounts = await storage.getGlobalFoldersWithCounts(MASTER_USER_ID);
      res.json(foldersWithCounts);
    } catch (error) {
      console.error("Failed to get global playlists:", error);
      res.status(500).json({ error: "Failed to get global playlists" });
    }
  });

  app.get("/api/global/playlists/:id/videos", isAuthenticated, async (req: Request, res: Response) => {
    try {
      if (!MASTER_USER_ID) return res.json([]);
      const videos = await storage.getGlobalVideos(MASTER_USER_ID, req.params.id as string);
      res.json(videos);
    } catch (error) {
      res.status(500).json({ error: "Failed to get global playlist videos" });
    }
  });

  app.get("/api/global/subscriptions", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const subs = await storage.getSubscriptions(userId);
      res.json(subs);
    } catch (error) {
      res.status(500).json({ error: "Failed to get subscriptions" });
    }
  });

  app.post("/api/global/subscribe", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      if (!MASTER_USER_ID) return res.status(400).json({ error: "No master account configured" });
      if (userId === MASTER_USER_ID) return res.status(400).json({ error: "You already own these playlists" });
      const parsed = insertGlobalSubscriptionSchema.safeParse(req.body);
      if (!parsed.success) return res.status(400).json({ error: parsed.error.message });
      const masterFolders = await storage.getGlobalFolders(MASTER_USER_ID);
      const folderExists = masterFolders.some(f => f.id === parsed.data.masterFolderId);
      if (!folderExists) return res.status(404).json({ error: "Playlist not found" });
      const sub = await storage.subscribe(userId, parsed.data.masterFolderId, parsed.data.kidIds, MASTER_USER_ID);
      res.status(201).json(sub);
    } catch (error) {
      console.error("Failed to subscribe:", error);
      res.status(500).json({ error: "Failed to subscribe" });
    }
  });

  app.post("/api/global/unsubscribe", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const parsed = insertGlobalSubscriptionSchema.pick({ masterFolderId: true }).safeParse(req.body);
      if (!parsed.success) return res.status(400).json({ error: parsed.error.message });
      await storage.unsubscribe(userId, parsed.data.masterFolderId);
      res.json({ success: true });
    } catch (error) {
      console.error("Failed to unsubscribe:", error);
      res.status(500).json({ error: "Failed to unsubscribe" });
    }
  });

  app.post("/api/global/sync", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      if (!MASTER_USER_ID) return res.status(400).json({ error: "No master account configured" });
      const parsed = insertGlobalSubscriptionSchema.pick({ masterFolderId: true }).safeParse(req.body);
      if (!parsed.success) return res.status(400).json({ error: parsed.error.message });
      await storage.syncSubscription(userId, parsed.data.masterFolderId, MASTER_USER_ID);
      res.json({ success: true });
    } catch (error) {
      res.status(500).json({ error: "Failed to sync" });
    }
  });

  app.post("/api/feedback", isAuthenticated, async (req: Request, res: Response) => {
    try {
      const userId = getUserId(req);
      const parsed = insertFeedbackSchema.safeParse(req.body);
      if (!parsed.success) {
        return res.status(400).json({ error: parsed.error.message });
      }
      const feedback = await storage.createFeedback(parsed.data, userId);
      res.status(201).json(feedback);
    } catch (error) {
      console.error("Failed to create feedback:", error);
      res.status(500).json({ error: "Failed to submit feedback" });
    }
  });

  return httpServer;
}


========================================
FILE: server/storage.ts
========================================
import { randomUUID } from "crypto";
import { eq, and, inArray, count } from "drizzle-orm";
import type { Kid, Video, InsertKid, VoiceRecording, VideoProgress, Folder, InsertFolder, VideoPlatform, Feedback, InsertFeedback, GlobalSubscription } from "@shared/schema";
import { getVideoInfo, MAX_VIDEO_VIEWS, VIDEO_PRIORITY_DEFAULT, kidsTable, videosTable, foldersTable, feedbackTable, globalSubscriptionsTable } from "@shared/schema";
import { db } from "./db";

export interface IStorage {
  getKids(userId: string): Promise<Kid[]>;
  getKid(id: string, userId: string): Promise<Kid | undefined>;
  createKid(kid: InsertKid, userId: string): Promise<Kid>;
  updateKid(id: string, userId: string, updates: Partial<InsertKid>): Promise<Kid | null>;
  deleteKid(id: string, userId: string): Promise<boolean>;

  getFolders(userId: string): Promise<Folder[]>;
  getFolder(id: string, userId: string): Promise<Folder | undefined>;
  createFolder(folder: InsertFolder, userId: string): Promise<Folder>;
  updateFolder(id: string, userId: string, updates: Partial<InsertFolder>): Promise<Folder | null>;
  deleteFolder(id: string, userId: string): Promise<boolean>;

  getVideos(userId: string): Promise<Video[]>;
  getVideo(id: string, userId: string): Promise<Video | undefined>;
  createVideo(url: string, kidIds: string[] | undefined, allKids: Kid[], userId: string, folderId?: string | null, priority?: number): Promise<{ video: Video | null; error?: string }>;
  updateVideo(id: string, userId: string, updates: { priority?: number; folderId?: string | null }): Promise<Video | null>;
  deleteVideo(id: string, userId: string): Promise<boolean>;
  markVideoWatched(videoId: string, kidId: string, voiceRecording: VoiceRecording, userId: string): Promise<{ video: Video | null; error?: string }>;

  createFeedback(feedback: InsertFeedback, userId: string): Promise<Feedback>;

  getBadgeCountForKid(kidId: string, userId: string): Promise<number>;
  getBadgeCountForParent(userId: string): Promise<number>;
  clearParentBadge(userId: string): Promise<void>;

  getKidById(kidId: string): Promise<(Kid & { userId: string }) | undefined>;
  getVideosByOwner(userId: string): Promise<Video[]>;
  getFoldersByOwner(userId: string): Promise<Folder[]>;
  markVideoWatchedPublic(videoId: string, kidId: string, voiceRecording: VoiceRecording, ownerUserId: string): Promise<{ video: Video | null; error?: string }>;

  getGlobalFolders(masterUserId: string): Promise<Folder[]>;
  getGlobalFoldersWithCounts(masterUserId: string): Promise<(Folder & { videoCount: number })[]>;
  getGlobalVideos(masterUserId: string, folderId: string): Promise<Video[]>;
  getSubscriptions(userId: string): Promise<GlobalSubscription[]>;
  subscribe(userId: string, masterFolderId: string, kidIds: string[], masterUserId: string): Promise<GlobalSubscription>;
  unsubscribe(userId: string, masterFolderId: string): Promise<boolean>;
  syncSubscription(userId: string, masterFolderId: string, masterUserId: string): Promise<void>;
  syncAllSubscriptions(userId: string, masterUserId: string): Promise<void>;
  cleanupGlobalData(userId: string): Promise<void>;
}

export class DatabaseStorage implements IStorage {
  async getKids(userId: string): Promise<Kid[]> {
    const rows = await db.select().from(kidsTable).where(eq(kidsTable.userId, userId));
    return rows.map(r => ({ id: r.id, name: r.name, avatar: r.avatar as Kid["avatar"] }));
  }

  async getKid(id: string, userId: string): Promise<Kid | undefined> {
    const rows = await db.select().from(kidsTable).where(and(eq(kidsTable.id, id), eq(kidsTable.userId, userId)));
    if (rows.length === 0) return undefined;
    const r = rows[0];
    return { id: r.id, name: r.name, avatar: r.avatar as Kid["avatar"] };
  }

  async createKid(insertKid: InsertKid, userId: string): Promise<Kid> {
    const id = `kid_${Date.now()}_${randomUUID().slice(0, 8)}`;
    const kid: Kid = { ...insertKid, id };
    await db.insert(kidsTable).values({ ...kid, userId });

    const allVideos = await this.getVideos(userId);
    for (const video of allVideos) {
      video.assigned[id] = true;
      video.progress[id] = { watched: false };
      await db.update(videosTable)
        .set({ assigned: video.assigned, progress: video.progress })
        .where(eq(videosTable.id, video.id));
    }

    return kid;
  }

  async updateKid(id: string, userId: string, updates: Partial<InsertKid>): Promise<Kid | null> {
    const existing = await this.getKid(id, userId);
    if (!existing) return null;
    const updated = { ...existing, ...updates };
    await db.update(kidsTable).set({ name: updated.name, avatar: updated.avatar }).where(and(eq(kidsTable.id, id), eq(kidsTable.userId, userId)));
    return updated;
  }

  async deleteKid(id: string, userId: string): Promise<boolean> {
    await db.delete(kidsTable).where(and(eq(kidsTable.id, id), eq(kidsTable.userId, userId)));
    return true;
  }

  async getFolders(userId: string): Promise<Folder[]> {
    const rows = await db.select().from(foldersTable).where(eq(foldersTable.userId, userId));
    return rows.map(r => ({ id: r.id, name: r.name }));
  }

  async getFolder(id: string, userId: string): Promise<Folder | undefined> {
    const rows = await db.select().from(foldersTable).where(and(eq(foldersTable.id, id), eq(foldersTable.userId, userId)));
    if (rows.length === 0) return undefined;
    return { id: rows[0].id, name: rows[0].name };
  }

  async createFolder(insertFolder: InsertFolder, userId: string): Promise<Folder> {
    const id = `folder_${Date.now()}_${randomUUID().slice(0, 8)}`;
    const folder: Folder = { ...insertFolder, id };
    await db.insert(foldersTable).values({ ...folder, userId });
    return folder;
  }

  async updateFolder(id: string, userId: string, updates: Partial<InsertFolder>): Promise<Folder | null> {
    const existing = await this.getFolder(id, userId);
    if (!existing) return null;
    const updated = { ...existing, ...updates };
    await db.update(foldersTable).set({ name: updated.name }).where(and(eq(foldersTable.id, id), eq(foldersTable.userId, userId)));
    return updated;
  }

  async deleteFolder(id: string, userId: string): Promise<boolean> {
    await db.update(videosTable)
      .set({ folderId: null })
      .where(and(eq(videosTable.folderId, id), eq(videosTable.userId, userId)));
    await db.delete(foldersTable).where(and(eq(foldersTable.id, id), eq(foldersTable.userId, userId)));
    return true;
  }

  async getVideos(userId: string): Promise<Video[]> {
    const rows = await db.select().from(videosTable).where(eq(videosTable.userId, userId));
    return rows.map(r => ({
      id: r.id,
      url: r.url,
      ytId: r.ytId,
      platform: (r.platform || "youtube") as VideoPlatform,
      folderId: r.folderId,
      priority: r.priority ?? VIDEO_PRIORITY_DEFAULT,
      assigned: r.assigned,
      progress: r.progress,
      totalViews: r.totalViews,
    }));
  }

  async getVideo(id: string, userId: string): Promise<Video | undefined> {
    const rows = await db.select().from(videosTable).where(and(eq(videosTable.id, id), eq(videosTable.userId, userId)));
    if (rows.length === 0) return undefined;
    const r = rows[0];
    return {
      id: r.id,
      url: r.url,
      ytId: r.ytId,
      platform: (r.platform || "youtube") as VideoPlatform,
      folderId: r.folderId,
      priority: r.priority ?? VIDEO_PRIORITY_DEFAULT,
      assigned: r.assigned,
      progress: r.progress,
      totalViews: r.totalViews,
    };
  }

  async createVideo(url: string, kidIds: string[] | undefined, allKids: Kid[], userId: string, folderId?: string | null, priority?: number): Promise<{ video: Video | null; error?: string }> {
    const videoInfo = getVideoInfo(url);
    if (!videoInfo) return { video: null, error: "Invalid video URL. Please paste a valid YouTube or TikTok link." };

    const { platform, videoId } = videoInfo;

    const existing = await db.select().from(videosTable).where(and(eq(videosTable.ytId, videoId), eq(videosTable.userId, userId)));
    if (existing.length > 0) return { video: null, error: "This video has already been added to your library." };

    const id = `vid_${Date.now()}_${randomUUID().slice(0, 8)}`;
    const assigned: Record<string, boolean> = {};
    const progress: Record<string, VideoProgress> = {};

    const targetKids = kidIds && kidIds.length > 0
      ? allKids.filter(k => kidIds.includes(k.id))
      : allKids;

    for (const kid of targetKids) {
      assigned[kid.id] = true;
      progress[kid.id] = { watched: false };
    }

    const videoPriority = priority ?? VIDEO_PRIORITY_DEFAULT;
    const video: Video = { id, url, ytId: videoId, platform, folderId: folderId || null, priority: videoPriority, assigned, progress, totalViews: 0 };
    await db.insert(videosTable).values({ ...video, userId, folderId: folderId || null, priority: videoPriority });
    return { video };
  }

  async updateVideo(id: string, userId: string, updates: { priority?: number; folderId?: string | null }): Promise<Video | null> {
    const video = await this.getVideo(id, userId);
    if (!video) return null;
    
    const updateData: Partial<{ priority: number; folderId: string | null }> = {};
    if (updates.priority !== undefined) updateData.priority = updates.priority;
    if (updates.folderId !== undefined) updateData.folderId = updates.folderId;
    
    if (Object.keys(updateData).length > 0) {
      await db.update(videosTable).set(updateData).where(and(eq(videosTable.id, id), eq(videosTable.userId, userId)));
    }
    
    return this.getVideo(id, userId) as Promise<Video>;
  }

  async deleteVideo(id: string, userId: string): Promise<boolean> {
    await db.delete(videosTable).where(and(eq(videosTable.id, id), eq(videosTable.userId, userId)));
    return true;
  }

  async markVideoWatched(videoId: string, kidId: string, voiceRecording: VoiceRecording, userId: string): Promise<{ video: Video | null; error?: string }> {
    const video = await this.getVideo(videoId, userId);
    if (!video) return { video: null, error: "Video not found" };

    const alreadyWatched = video.progress[kidId]?.watched;

    if (!alreadyWatched && video.totalViews >= MAX_VIDEO_VIEWS) {
      return { video: null, error: "This video has reached the maximum number of views (4)" };
    }

    const existingRecordings = video.progress[kidId]?.voiceRecordings || [];
    const legacySingle = video.progress[kidId]?.voiceRecording;
    if (legacySingle && existingRecordings.length === 0) {
      existingRecordings.push(legacySingle);
    }
    
    existingRecordings.push(voiceRecording);

    video.progress[kidId] = {
      watched: true,
      watchedAt: video.progress[kidId]?.watchedAt || new Date().toISOString(),
      voiceRecordings: existingRecordings,
      parentReviewed: false,
    };
    
    if (!alreadyWatched) {
      video.totalViews = (video.totalViews || 0) + 1;
    }

    await db.update(videosTable)
      .set({ progress: video.progress, totalViews: video.totalViews })
      .where(and(eq(videosTable.id, videoId), eq(videosTable.userId, userId)));

    return { video };
  }

  async getKidById(kidId: string): Promise<(Kid & { userId: string }) | undefined> {
    const rows = await db.select().from(kidsTable).where(eq(kidsTable.id, kidId));
    if (rows.length === 0) return undefined;
    const r = rows[0];
    return { id: r.id, name: r.name, avatar: r.avatar as Kid["avatar"], userId: r.userId };
  }

  async getVideosByOwner(userId: string): Promise<Video[]> {
    return this.getVideos(userId);
  }

  async getFoldersByOwner(userId: string): Promise<Folder[]> {
    return this.getFolders(userId);
  }

  async markVideoWatchedPublic(videoId: string, kidId: string, voiceRecording: VoiceRecording, ownerUserId: string): Promise<{ video: Video | null; error?: string }> {
    return this.markVideoWatched(videoId, kidId, voiceRecording, ownerUserId);
  }

  async getBadgeCountForKid(kidId: string, userId: string): Promise<number> {
    const videos = await this.getVideos(userId);
    let count = 0;
    for (const video of videos) {
      if (video.assigned?.[kidId] && !video.progress?.[kidId]?.watched) {
        count++;
      }
    }
    return count;
  }

  async getBadgeCountForParent(userId: string): Promise<number> {
    const videos = await this.getVideos(userId);
    let count = 0;
    for (const video of videos) {
      for (const kidId of Object.keys(video.progress || {})) {
        const prog = video.progress[kidId];
        if (prog?.watched && prog?.parentReviewed === false) {
          count++;
        }
      }
    }
    return count;
  }

  async clearParentBadge(userId: string): Promise<void> {
    const videos = await this.getVideos(userId);
    for (const video of videos) {
      let changed = false;
      for (const kidId of Object.keys(video.progress || {})) {
        if (video.progress[kidId]?.watched && video.progress[kidId]?.parentReviewed === false) {
          video.progress[kidId].parentReviewed = true;
          changed = true;
        }
      }
      if (changed) {
        await db.update(videosTable)
          .set({ progress: video.progress })
          .where(and(eq(videosTable.id, video.id), eq(videosTable.userId, userId)));
      }
    }
  }

  async createFeedback(feedback: InsertFeedback, userId: string): Promise<Feedback> {
    const id = `fb_${Date.now()}_${randomUUID().slice(0, 8)}`;
    const createdAt = new Date();
    await db.insert(feedbackTable).values({
      id,
      userId,
      type: feedback.type,
      content: feedback.content,
      createdAt,
    });
    return {
      id,
      userId,
      type: feedback.type as Feedback["type"],
      content: feedback.content,
      createdAt: createdAt.toISOString(),
    };
  }

  async getGlobalFolders(masterUserId: string): Promise<Folder[]> {
    const rows = await db.select().from(foldersTable).where(eq(foldersTable.userId, masterUserId));
    return rows.filter(r => !r.name.startsWith("__global_")).map(r => ({ id: r.id, name: r.name }));
  }

  async getGlobalFoldersWithCounts(masterUserId: string): Promise<(Folder & { videoCount: number })[]> {
    const folders = await this.getGlobalFolders(masterUserId);
    if (folders.length === 0) return [];
    const folderIds = folders.map(f => f.id);
    const countRows = await db
      .select({ folderId: videosTable.folderId, videoCount: count() })
      .from(videosTable)
      .where(and(
        eq(videosTable.userId, masterUserId),
        inArray(videosTable.folderId, folderIds)
      ))
      .groupBy(videosTable.folderId);
    const countMap = new Map(countRows.map(r => [r.folderId, Number(r.videoCount)]));
    return folders.map(f => ({ ...f, videoCount: countMap.get(f.id) || 0 }));
  }

  async getGlobalVideos(masterUserId: string, folderId: string): Promise<Video[]> {
    const rows = await db.select().from(videosTable).where(
      and(eq(videosTable.userId, masterUserId), eq(videosTable.folderId, folderId))
    );
    return rows.map(r => ({
      id: r.id,
      url: r.url,
      ytId: r.ytId,
      platform: (r.platform || "youtube") as VideoPlatform,
      folderId: r.folderId,
      priority: r.priority ?? VIDEO_PRIORITY_DEFAULT,
      assigned: r.assigned,
      progress: r.progress,
      totalViews: r.totalViews,
    }));
  }

  async getSubscriptions(userId: string): Promise<GlobalSubscription[]> {
    const rows = await db.select().from(globalSubscriptionsTable).where(eq(globalSubscriptionsTable.userId, userId));
    return rows.map(r => ({
      id: r.id,
      userId: r.userId,
      masterFolderId: r.masterFolderId,
      kidIds: r.kidIds as string[],
      createdAt: r.createdAt?.toISOString(),
    }));
  }

  async subscribe(userId: string, masterFolderId: string, kidIds: string[], masterUserId: string): Promise<GlobalSubscription> {
    const existing = await db.select().from(globalSubscriptionsTable).where(
      and(eq(globalSubscriptionsTable.userId, userId), eq(globalSubscriptionsTable.masterFolderId, masterFolderId))
    );
    if (existing.length > 0) {
      await db.update(globalSubscriptionsTable)
        .set({ kidIds })
        .where(eq(globalSubscriptionsTable.id, existing[0].id));
      await this.syncSubscription(userId, masterFolderId, masterUserId);
      return { id: existing[0].id, userId, masterFolderId, kidIds, createdAt: existing[0].createdAt?.toISOString() };
    }

    const id = `gsub_${Date.now()}_${randomUUID().slice(0, 8)}`;
    const createdAt = new Date();
    await db.insert(globalSubscriptionsTable).values({ id, userId, masterFolderId, kidIds, createdAt });

    await this.syncSubscription(userId, masterFolderId, masterUserId);

    return { id, userId, masterFolderId, kidIds, createdAt: createdAt.toISOString() };
  }

  async unsubscribe(userId: string, masterFolderId: string): Promise<boolean> {
    const sub = await db.select().from(globalSubscriptionsTable).where(
      and(eq(globalSubscriptionsTable.userId, userId), eq(globalSubscriptionsTable.masterFolderId, masterFolderId))
    );
    if (sub.length === 0) return false;

    const localFolder = await db.select().from(foldersTable).where(
      and(eq(foldersTable.userId, userId), eq(foldersTable.name, `__global_${masterFolderId}`))
    );
    if (localFolder.length > 0) {
      await db.delete(videosTable).where(
        and(eq(videosTable.userId, userId), eq(videosTable.folderId, localFolder[0].id))
      );
      await db.delete(foldersTable).where(eq(foldersTable.id, localFolder[0].id));
    }

    await db.delete(globalSubscriptionsTable).where(eq(globalSubscriptionsTable.id, sub[0].id));
    return true;
  }

  async syncSubscription(userId: string, masterFolderId: string, masterUserId: string): Promise<void> {
    const sub = await db.select().from(globalSubscriptionsTable).where(
      and(eq(globalSubscriptionsTable.userId, userId), eq(globalSubscriptionsTable.masterFolderId, masterFolderId))
    );
    if (sub.length === 0) return;

    const kidIds = sub[0].kidIds as string[];
    const allKids = await this.getKids(userId);
    const targetKids = kidIds.length > 0 ? allKids.filter(k => kidIds.includes(k.id)) : allKids;

    const masterFolder = await db.select().from(foldersTable).where(
      and(eq(foldersTable.id, masterFolderId), eq(foldersTable.userId, masterUserId))
    );
    if (masterFolder.length === 0) return;

    const localFolderName = `__global_${masterFolderId}`;
    let localFolderRows = await db.select().from(foldersTable).where(
      and(eq(foldersTable.userId, userId), eq(foldersTable.name, localFolderName))
    );

    let localFolderId: string;
    if (localFolderRows.length === 0) {
      localFolderId = `folder_${Date.now()}_${randomUUID().slice(0, 8)}`;
      await db.insert(foldersTable).values({ id: localFolderId, userId, name: localFolderName });
    } else {
      localFolderId = localFolderRows[0].id;
    }

    const masterVideos = await this.getGlobalVideos(masterUserId, masterFolderId);
    const existingLocal = await db.select().from(videosTable).where(
      and(eq(videosTable.userId, userId), eq(videosTable.folderId, localFolderId))
    );
    const existingYtIds = new Set(existingLocal.map(v => v.ytId));

    for (const mv of masterVideos) {
      if (existingYtIds.has(mv.ytId)) continue;

      const id = `vid_${Date.now()}_${randomUUID().slice(0, 8)}_g`;
      const assigned: Record<string, boolean> = {};
      const progress: Record<string, VideoProgress> = {};
      for (const kid of targetKids) {
        assigned[kid.id] = true;
        progress[kid.id] = { watched: false };
      }

      await db.insert(videosTable).values({
        id,
        userId,
        url: mv.url,
        ytId: mv.ytId,
        platform: mv.platform,
        folderId: localFolderId,
        priority: mv.priority,
        assigned,
        progress,
        totalViews: 0,
      });
    }
  }

  async syncAllSubscriptions(userId: string, masterUserId: string): Promise<void> {
    const subs = await db.select().from(globalSubscriptionsTable).where(eq(globalSubscriptionsTable.userId, userId));
    for (const sub of subs) {
      await this.syncSubscription(userId, sub.masterFolderId, masterUserId);
    }
  }

  async cleanupGlobalData(userId: string): Promise<void> {
    const allFolders = await db.select().from(foldersTable).where(eq(foldersTable.userId, userId));
    const globalFolders = allFolders.filter(f => f.name.startsWith("__global_"));

    for (const gf of globalFolders) {
      await db.delete(videosTable).where(
        and(eq(videosTable.userId, userId), eq(videosTable.folderId, gf.id))
      );
      await db.delete(foldersTable).where(eq(foldersTable.id, gf.id));
    }

    await db.delete(globalSubscriptionsTable).where(eq(globalSubscriptionsTable.userId, userId));
  }
}

export const storage = new DatabaseStorage();


========================================
FILE: server/db/index.ts
========================================
import { drizzle } from "drizzle-orm/node-postgres";
import { Pool } from "pg";
import * as schema from "@shared/schema";

const pool = new Pool({
  connectionString: process.env.DATABASE_URL,
});

export const db = drizzle(pool, { schema });


========================================
FILE: server/vite.ts
========================================
import { type Express } from "express";
import { createServer as createViteServer, createLogger } from "vite";
import { type Server } from "http";
import viteConfig from "../vite.config";
import fs from "fs";
import path from "path";
import { nanoid } from "nanoid";

const viteLogger = createLogger();

export async function setupVite(server: Server, app: Express) {
  const serverOptions = {
    middlewareMode: true,
    hmr: { server, path: "/vite-hmr" },
    allowedHosts: true as const,
  };

  const vite = await createViteServer({
    ...viteConfig,
    configFile: false,
    customLogger: {
      ...viteLogger,
      error: (msg, options) => {
        viteLogger.error(msg, options);
        process.exit(1);
      },
    },
    server: serverOptions,
    appType: "custom",
  });

  app.use(vite.middlewares);

  app.use("/{*path}", async (req, res, next) => {
    const url = req.originalUrl;

    try {
      const clientTemplate = path.resolve(
        import.meta.dirname,
        "..",
        "client",
        "index.html",
      );

      // always reload the index.html file from disk incase it changes
      let template = await fs.promises.readFile(clientTemplate, "utf-8");
      template = template.replace(
        `src="/src/main.tsx"`,
        `src="/src/main.tsx?v=${nanoid()}"`,
      );
      const page = await vite.transformIndexHtml(url, template);
      res.status(200).set({ "Content-Type": "text/html" }).end(page);
    } catch (e) {
      vite.ssrFixStacktrace(e as Error);
      next(e);
    }
  });
}


========================================
FILE: server/static.ts
========================================
import express, { type Express } from "express";
import fs from "fs";
import path from "path";

export function serveStatic(app: Express) {
  const distPath = path.resolve(__dirname, "public");
  if (!fs.existsSync(distPath)) {
    throw new Error(
      `Could not find the build directory: ${distPath}, make sure to build the client first`,
    );
  }

  app.use(express.static(distPath));

  // fall through to index.html if the file doesn't exist
  app.use("/{*path}", (_req, res) => {
    res.sendFile(path.resolve(distPath, "index.html"));
  });
}


========================================
FILE: server/replit_integrations/auth/index.ts
========================================
export { setupAuth, isAuthenticated, getSession } from "./replitAuth";
export { authStorage, type IAuthStorage } from "./storage";
export { registerAuthRoutes } from "./routes";


========================================
FILE: server/replit_integrations/auth/replitAuth.ts
========================================
import * as client from "openid-client";
import { Strategy, type VerifyFunction } from "openid-client/passport";

import passport from "passport";
import session from "express-session";
import type { Express, RequestHandler } from "express";
import memoize from "memoizee";
import connectPg from "connect-pg-simple";
import { authStorage } from "./storage";

const getOidcConfig = memoize(
  async () => {
    return await client.discovery(
      new URL(process.env.ISSUER_URL ?? "https://replit.com/oidc"),
      process.env.REPL_ID!
    );
  },
  { maxAge: 3600 * 1000 }
);

export function getSession() {
  const sessionTtl = 7 * 24 * 60 * 60 * 1000; // 1 week
  const pgStore = connectPg(session);
  const sessionStore = new pgStore({
    conString: process.env.DATABASE_URL,
    createTableIfMissing: false,
    ttl: sessionTtl,
    tableName: "sessions",
  });
  return session({
    secret: process.env.SESSION_SECRET!,
    store: sessionStore,
    resave: false,
    saveUninitialized: false,
    cookie: {
      httpOnly: true,
      secure: true,
      maxAge: sessionTtl,
    },
  });
}

function updateUserSession(
  user: any,
  tokens: client.TokenEndpointResponse & client.TokenEndpointResponseHelpers
) {
  user.claims = tokens.claims();
  user.access_token = tokens.access_token;
  user.refresh_token = tokens.refresh_token;
  user.expires_at = user.claims?.exp;
}

async function upsertUser(claims: any) {
  await authStorage.upsertUser({
    id: String(claims["sub"]),
    email: claims["email"],
    firstName: claims["first_name"],
    lastName: claims["last_name"],
    profileImageUrl: claims["profile_image_url"],
  });
}

export async function setupAuth(app: Express) {
  app.set("trust proxy", 1);
  app.use(getSession());
  app.use(passport.initialize());
  app.use(passport.session());

  const config = await getOidcConfig();

  const verify: VerifyFunction = async (
    tokens: client.TokenEndpointResponse & client.TokenEndpointResponseHelpers,
    verified: passport.AuthenticateCallback
  ) => {
    const user = {};
    updateUserSession(user, tokens);
    await upsertUser(tokens.claims());
    verified(null, user);
  };

  // Keep track of registered strategies
  const registeredStrategies = new Set<string>();

  // Helper function to ensure strategy exists for a domain
  const ensureStrategy = (domain: string) => {
    const strategyName = `replitauth:${domain}`;
    if (!registeredStrategies.has(strategyName)) {
      const strategy = new Strategy(
        {
          name: strategyName,
          config,
          scope: "openid email profile offline_access",
          callbackURL: `https://${domain}/api/callback`,
        },
        verify
      );
      passport.use(strategy);
      registeredStrategies.add(strategyName);
    }
  };

  passport.serializeUser((user: Express.User, cb) => cb(null, user));
  passport.deserializeUser((user: Express.User, cb) => cb(null, user));

  app.get("/api/login", (req, res, next) => {
    ensureStrategy(req.hostname);
    passport.authenticate(`replitauth:${req.hostname}`, {
      prompt: "login consent",
      scope: ["openid", "email", "profile", "offline_access"],
    })(req, res, next);
  });

  app.get("/api/callback", (req, res, next) => {
    ensureStrategy(req.hostname);
    passport.authenticate(`replitauth:${req.hostname}`, {
      successReturnToOrRedirect: "/",
      failureRedirect: "/api/login",
    })(req, res, next);
  });

  app.get("/api/logout", (req, res) => {
    req.logout(() => {
      res.redirect(
        client.buildEndSessionUrl(config, {
          client_id: process.env.REPL_ID!,
          post_logout_redirect_uri: `${req.protocol}://${req.hostname}`,
        }).href
      );
    });
  });
}

export const isAuthenticated: RequestHandler = async (req, res, next) => {
  const user = req.user as any;

  if (!req.isAuthenticated() || !user?.claims?.sub) {
    return res.status(401).json({ message: "Unauthorized" });
  }

  const now = Math.floor(Date.now() / 1000);
  if (user.expires_at && now > user.expires_at) {
    const refreshToken = user.refresh_token;
    if (refreshToken) {
      try {
        const config = await getOidcConfig();
        const tokenResponse = await client.refreshTokenGrant(config, refreshToken);
        updateUserSession(user, tokenResponse);
        req.session.save(() => {});
      } catch (_error) {
      }
    }
  }

  return next();
};


========================================
FILE: server/replit_integrations/auth/routes.ts
========================================
import type { Express } from "express";
import { authStorage } from "./storage";
import { isAuthenticated } from "./replitAuth";

// Register auth-specific routes
export function registerAuthRoutes(app: Express): void {
  // Get current authenticated user
  app.get("/api/auth/user", isAuthenticated, async (req: any, res) => {
    try {
      const userId = req.user.claims.sub;
      const user = await authStorage.getUser(userId);
      res.json(user);
    } catch (error) {
      console.error("Error fetching user:", error);
      res.status(500).json({ message: "Failed to fetch user" });
    }
  });
}


========================================
FILE: server/replit_integrations/auth/storage.ts
========================================
import { users, type User, type UpsertUser } from "@shared/models/auth";
import { db } from "../../db";
import { eq } from "drizzle-orm";

// Interface for auth storage operations
// (IMPORTANT) These user operations are mandatory for Replit Auth.
export interface IAuthStorage {
  getUser(id: string): Promise<User | undefined>;
  upsertUser(user: UpsertUser): Promise<User>;
}

class AuthStorage implements IAuthStorage {
  async getUser(id: string): Promise<User | undefined> {
    const [user] = await db.select().from(users).where(eq(users.id, id));
    return user;
  }

  async upsertUser(userData: UpsertUser): Promise<User> {
    const [user] = await db
      .insert(users)
      .values(userData)
      .onConflictDoUpdate({
        target: users.id,
        set: {
          ...userData,
          updatedAt: new Date(),
        },
      })
      .returning();
    return user;
  }
}

export const authStorage = new AuthStorage();


========================================
FILE: script/build.ts
========================================
import { build as esbuild } from "esbuild";
import { build as viteBuild } from "vite";
import { rm, readFile } from "fs/promises";

// server deps to bundle to reduce openat(2) syscalls
// which helps cold start times
const allowlist = [
  "@google/generative-ai",
  "axios",
  "connect-pg-simple",
  "cors",
  "date-fns",
  "drizzle-orm",
  "drizzle-zod",
  "express",
  "express-rate-limit",
  "express-session",
  "jsonwebtoken",
  "memorystore",
  "multer",
  "nanoid",
  "nodemailer",
  "openai",
  "passport",
  "passport-local",
  "pg",
  "stripe",
  "uuid",
  "ws",
  "xlsx",
  "zod",
  "zod-validation-error",
];

async function buildAll() {
  await rm("dist", { recursive: true, force: true });

  console.log("building client...");
  await viteBuild();

  console.log("building server...");
  const pkg = JSON.parse(await readFile("package.json", "utf-8"));
  const allDeps = [
    ...Object.keys(pkg.dependencies || {}),
    ...Object.keys(pkg.devDependencies || {}),
  ];
  const externals = allDeps.filter((dep) => !allowlist.includes(dep));

  await esbuild({
    entryPoints: ["server/index.ts"],
    platform: "node",
    bundle: true,
    format: "cjs",
    outfile: "dist/index.cjs",
    define: {
      "process.env.NODE_ENV": '"production"',
    },
    minify: true,
    external: externals,
    logLevel: "info",
  });
}

buildAll().catch((err) => {
  console.error(err);
  process.exit(1);
});


